<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>GLB Overwatch Viewer v23-mobile</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"/>

<style>
html,body{
  margin:0;
  padding:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#0b3a3a;
  touch-action:none;
  font-family:system-ui,-apple-system,BlinkMacSystemFont;
}

#hud{
  position:absolute;
  top:12px;
  left:12px;
  background:rgba(0,0,0,.6);
  color:#fff;
  padding:12px 14px;
  border-radius:14px;
  font-size:14px;
  z-index:10;
}

#version{
  position:absolute;
  top:12px;
  right:12px;
  background:#000;
  color:#6ff;
  padding:6px 10px;
  border-radius:999px;
  font-size:12px;
  z-index:10;
}

.joy{
  position:absolute;
  bottom:24px;
  width:140px;
  height:140px;
  border-radius:50%;
  background:rgba(255,255,255,.08);
  z-index:10;
}

#joyL{ left:24px; }
#joyR{ right:24px; }

.knob{
  position:absolute;
  left:50%;
  top:50%;
  width:60px;
  height:60px;
  margin:-30px;
  border-radius:50%;
  background:rgba(255,255,255,.35);
}
</style>
</head>

<body>
<div id="hud">
<b>FINAL HUMAN CONTROL MODEL</b><br/>
üëÅ Look: 1-finger drag<br/>
üïπ Move: dual joysticks<br/>
üõ∞ Double-tap: camera mode
</div>
<div id="version">v23-mobile</div>

<div id="joyL" class="joy"><div class="knob"></div></div>
<div id="joyR" class="joy"><div class="knob"></div></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTFFileLoader.js"></script>

<script>
/* ================= ENGINE ================= */
const canvas=document.createElement("canvas");
canvas.style.position="fixed";
canvas.style.top="0";
canvas.style.left="0";
canvas.style.width="100vw";
canvas.style.height="100vh";
document.body.appendChild(canvas);

const engine=new BABYLON.Engine(canvas,true);
engine.resize();

const scene=new BABYLON.Scene(engine);
scene.clearColor=new BABYLON.Color4(0.05,0.2,0.2,1);

/* ================= STATE ================= */
const state={
  speed:0.8,
  vert:0.6,
  look:0.002,
  mode:"free" // free | follow | orbit
};

const BASE_FOV=0.8;
let targetFov=BASE_FOV;

/* ================= CAMERA ================= */
const camera=new BABYLON.UniversalCamera(
  "cam",
  new BABYLON.Vector3(0,20,-60),
  scene
);
scene.activeCamera=camera;
camera.attachControl(canvas,false);
camera.speed=0;
camera.fov=BASE_FOV;

/* ================= LIGHT ================= */
new BABYLON.HemisphericLight(
  "light",
  new BABYLON.Vector3(0,1,0),
  scene
);

/* ================= GRID ================= */
const grid=BABYLON.MeshBuilder.CreateGround(
  "grid",
  {width:500,height:500},
  scene
);
const gm=new BABYLON.StandardMaterial("gm",scene);
gm.wireframe=true;
gm.emissiveColor=new BABYLON.Color3(0,1,1);
grid.material=gm;

/* ================= LOAD URL ASSETS ================= */
const params=new URLSearchParams(location.search);
const avatarURL=params.get("avatar");
const worldURLs=params.getAll("world");

let target=null;

if(avatarURL){
  BABYLON.SceneLoader.ImportMeshAsync(null,"",avatarURL,scene)
  .then(res=>{
    target=res.meshes.find(m=>!m.parent)||res.meshes[0];
  });
}

worldURLs.forEach((url,i)=>{
  BABYLON.SceneLoader.ImportMeshAsync(null,"",url,scene)
  .then(res=>{
    const root=res.meshes.find(m=>!m.parent)||res.meshes[0];
    root.position.set(
      (i%4)*50-75,
      0,
      Math.floor(i/4)*50
    );
  });
});

/* ================= LOOK ================= */
let lx=0,ly=0,looking=false;
const PITCH_LIMIT=Math.PI/2.2;

canvas.addEventListener("pointerdown",e=>{
  if(e.target.closest(".joy")) return;
  looking=true;
  lx=e.clientX;
  ly=e.clientY;
});

canvas.addEventListener("pointermove",e=>{
  if(!looking) return;
  camera.rotation.y+=(e.clientX-lx)*state.look;
  camera.rotation.x+=(e.clientY-ly)*state.look;
  camera.rotation.x=Math.max(
    -PITCH_LIMIT,
    Math.min(PITCH_LIMIT,camera.rotation.x)
  );
  lx=e.clientX;
  ly=e.clientY;
});

addEventListener("pointerup",()=>looking=false);

/* ================= JOYSTICKS ================= */
function makeJoy(el){
  const knob=el.querySelector(".knob");
  let x=0,y=0,active=false;

  el.onpointerdown=e=>{
    active=true;
    el.setPointerCapture(e.pointerId);
  };

  el.onpointermove=e=>{
    if(!active) return;
    const r=el.getBoundingClientRect();
    x=(e.clientX-(r.left+r.width/2))/(r.width/2);
    y=(e.clientY-(r.top+r.height/2))/(r.height/2);
    x=Math.max(-1,Math.min(1,x));
    y=Math.max(-1,Math.min(1,y));
    knob.style.transform=`translate(${x*40}px,${y*40}px)`;
  };

  el.onpointerup=()=>{
    active=false;
    x=y=0;
    knob.style.transform="";
  };

  return()=>({x,y});
}

const joyL=makeJoy(document.getElementById("joyL"));
const joyR=makeJoy(document.getElementById("joyR"));

/* ================= HELPERS ================= */
function dirs(){
  const y=camera.rotation.y;
  return{
    f:new BABYLON.Vector3(Math.sin(y),0,Math.cos(y)),
    r:new BABYLON.Vector3(Math.sin(y+Math.PI/2),0,Math.cos(y+Math.PI/2))
  };
}

/* ================= CAMERA MODES ================= */
function updateCameraMode(){
  if(!target) return;
  if(state.mode==="follow"){
    const off=new BABYLON.Vector3(0,12,-25);
    off.rotateByQuaternionToRef(
      BABYLON.Quaternion.FromEulerAngles(0,camera.rotation.y,0),
      off
    );
    camera.position.copyFrom(target.position.add(off));
    camera.setTarget(target.position);
  }
  if(state.mode==="orbit"){
    camera.setTarget(target.position);
  }
}

addEventListener("dblclick",()=>{
  state.mode=
    state.mode==="free"?"follow":
    state.mode==="follow"?"orbit":"free";
});

/* ================= LOOP ================= */
scene.onBeforeRenderObservable.add(()=>{
  const l=joyL(), r=joyR();
  const {f,r:rt}=dirs();

  if(state.mode==="free"){
    camera.position.addInPlace(f.scale(-l.y*state.speed));
    camera.position.addInPlace(rt.scale(l.x*state.speed));
    camera.position.y+=r.y*state.vert;
  }

  targetFov =
    l.x>0.6 ? 0.65 :
    l.x<-0.6 ? 1.0 :
    BASE_FOV;

  camera.fov+=(targetFov-camera.fov)*0.1;
  updateCameraMode();
});

engine.runRenderLoop(()=>scene.render());
addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>