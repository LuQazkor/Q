<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>GLB Auto Loader World</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"/>

<style>
html,body{
  margin:0;
  padding:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#0b3a3a;
  touch-action:none;
  font-family:system-ui;
}

#hud{
  position:absolute;
  top:12px;
  left:12px;
  background:rgba(0,0,0,.6);
  color:#fff;
  padding:12px 14px;
  border-radius:14px;
  font-size:14px;
  z-index:10;
}

.joy{
  position:absolute;
  bottom:24px;
  width:140px;
  height:140px;
  border-radius:50%;
  background:rgba(255,255,255,.08);
  z-index:10;
}
#joyL{ left:24px; }
#joyR{ right:24px; }

.knob{
  position:absolute;
  left:50%;
  top:50%;
  width:60px;
  height:60px;
  margin:-30px;
  border-radius:50%;
  background:rgba(255,255,255,.35);
}
</style>
</head>

<body>
<div id="hud">
<b>GLB AUTO WORLD</b><br/>
ðŸ•¹ Left: move<br/>
ðŸ•¹ Right: fly + turn<br/>
ðŸ‘† Drag: look<br/>
ðŸ“¦ /glb auto-loaded
</div>

<div id="joyL" class="joy"><div class="knob"></div></div>
<div id="joyR" class="joy"><div class="knob"></div></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTFFileLoader.js"></script>

<script>
/* ================= ENGINE ================= */
const canvas=document.createElement("canvas");
canvas.style.position="fixed";
canvas.style.top="0";
canvas.style.left="0";
canvas.style.width="100vw";
canvas.style.height="100vh";
document.body.appendChild(canvas);

const engine=new BABYLON.Engine(canvas,true);
engine.resize();

const scene=new BABYLON.Scene(engine);
scene.clearColor=new BABYLON.Color4(0.05,0.2,0.2,1);

/* ================= CAMERA ================= */
const camera=new BABYLON.UniversalCamera(
  "cam",
  new BABYLON.Vector3(0,8,-20),
  scene
);
scene.activeCamera=camera;
camera.attachControl(canvas,false);
camera.fov=0.8;

/* ================= LIGHT ================= */
new BABYLON.HemisphericLight("h",new BABYLON.Vector3(0,1,0),scene);

/* ================= GRID ================= */
const ground=BABYLON.MeshBuilder.CreateGround(
  "g",{width:500,height:500},scene
);
const gm=new BABYLON.StandardMaterial("gm",scene);
gm.wireframe=true;
gm.emissiveColor=new BABYLON.Color3(0,1,1);
ground.material=gm;

/* ================= JOYSTICKS ================= */
function makeJoy(el){
  const knob=el.querySelector(".knob");
  let x=0,y=0,active=false;

  el.onpointerdown=e=>{
    active=true;
    el.setPointerCapture(e.pointerId);
  };
  el.onpointermove=e=>{
    if(!active) return;
    const r=el.getBoundingClientRect();
    x=(e.clientX-(r.left+r.width/2))/(r.width/2);
    y=(e.clientY-(r.top+r.height/2))/(r.height/2);
    x=Math.max(-1,Math.min(1,x));
    y=Math.max(-1,Math.min(1,y));
    knob.style.transform=`translate(${x*40}px,${y*40}px)`;
  };
  el.onpointerup=()=>{
    active=false; x=y=0;
    knob.style.transform="";
  };
  return()=>({x,y});
}

const joyL=makeJoy(document.getElementById("joyL"));
const joyR=makeJoy(document.getElementById("joyR"));

/* ================= AVATAR ================= */
const params=new URLSearchParams(location.search);
const avatarURL=params.get("avatar");

let avatar;
let velocity=new BABYLON.Vector3();

if(avatarURL){
  BABYLON.SceneLoader.ImportMeshAsync(
    null,"",avatarURL,scene
  ).then(res=>{
    avatar=res.meshes.find(m=>!m.parent)||res.meshes[0];
    avatar.position.y=10;
  });
}

/* ================= LOAD ALL GLBS ================= */
async function loadAllGLB(){
  const res=await fetch("glb/");
  const text=await res.text();
  const matches=[...text.matchAll(/href="([^"]+\.glb)"/g)];
  const urls=[...new Set(matches.map(m=>m[1]))];

  const spacing=12;
  const cols=Math.ceil(Math.sqrt(urls.length));

  for(let i=0;i<urls.length;i++){
    const url="glb/"+urls[i].split("/").pop();

    BABYLON.SceneLoader.ImportMeshAsync(
      null,"",url,scene
    ).then(result=>{
      const root=result.meshes.find(m=>!m.parent)||result.meshes[0];

      // normalize size
      const box=root.getHierarchyBoundingVectors(true);
      const size=box.max.subtract(box.min);
      const maxDim=Math.max(size.x,size.y,size.z);
      const scale=6/maxDim;
      root.scaling.setAll(scale);

      // spread
      const x=(i%cols)*spacing - (cols*spacing)/2;
      const z=Math.floor(i/cols)*spacing - (cols*spacing)/2;
      root.position.set(x,0,z);
    });
  }
}

loadAllGLB();

/* ================= CAMERA LOOK ================= */
let looking=false,lastX=0,lastY=0;

canvas.onpointerdown=e=>{
  if(e.target.closest(".joy")) return;
  looking=true; lastX=e.clientX; lastY=e.clientY;
};

canvas.onpointermove=e=>{
  if(!looking) return;
  camera.rotation.y+=(e.clientX-lastX)*0.005;
  camera.rotation.x+=(e.clientY-lastY)*0.005;
  lastX=e.clientX; lastY=e.clientY;
};

canvas.onpointerup=()=>looking=false;

/* ================= LOOP ================= */
scene.onBeforeRenderObservable.add(()=>{
  if(!avatar) return;

  const l=joyL();
  const r=joyR();

  avatar.rotation.y+=r.x*0.05;

  const forward=new BABYLON.Vector3(
    Math.sin(avatar.rotation.y),
    0,
    Math.cos(avatar.rotation.y)
  );
  const right=new BABYLON.Vector3(
    Math.cos(avatar.rotation.y),
    0,
    -Math.sin(avatar.rotation.y)
  );

  velocity.copyFrom(
    forward.scale(l.y*0.6)
      .add(right.scale(l.x*0.6))
  );
  velocity.y=r.y*0.6;
  avatar.position.addInPlace(velocity);

  const camOffset=new BABYLON.Vector3(0,6,-16);
  camOffset.rotateByQuaternionToRef(
    BABYLON.Quaternion.FromEulerAngles(0,avatar.rotation.y,0),
    camOffset
  );
  camera.position.copyFrom(avatar.position.add(camOffset));
  camera.setTarget(avatar.position);
});

/* ================= RENDER ================= */
engine.runRenderLoop(()=>scene.render());
addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>