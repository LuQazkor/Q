<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>GLB World v8</title>

<style>
html,body{margin:0;width:100%;height:100%;overflow:hidden;background:#000;touch-action:none;-webkit-text-size-adjust:100%}
#c{width:100vw;height:100vh;display:block;background:#111;touch-action:none}
#version-badge{
  position:fixed;top:10px;right:10px;z-index:10000;
  padding:6px 10px;font:12px system-ui;color:#fff;background:rgba(0,0,0,.85);
  border:1px solid rgba(255,255,255,.30);border-radius:999px;pointer-events:none
}
#hud{
  position:fixed;top:10px;left:10px;z-index:9999;max-width:calc(100vw - 20px);
  font:13px system-ui;color:#fff;background:rgba(0,0,0,.72);
  border:1px solid rgba(255,255,255,.14);padding:10px;border-radius:12px
}
#hud .small{opacity:.92;font-size:12px;margin-top:6px;white-space:pre-wrap}
#hud .row{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
#hud button{
  border:0;border-radius:999px;padding:8px 10px;background:rgba(255,255,255,.12);
  color:#fff;font:13px system-ui;border:1px solid rgba(255,255,255,.18)
}
#hud button:active{transform:scale(.97)}
#mobile{position:fixed;left:0;right:0;bottom:0;z-index:9998;pointer-events:none}
.pad{
  pointer-events:auto;position:absolute;bottom:14px;width:150px;height:150px;border-radius:999px;
  background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.18);backdrop-filter: blur(6px)
}
#leftPad{left:14px}
#rightPad{right:14px;width:170px;height:170px}
.stick{
  position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
  width:64px;height:64px;border-radius:999px;background:rgba(255,255,255,.18);border:1px solid rgba(255,255,255,.22)
}
#btns{
  pointer-events:auto;position:absolute;left:50%;transform:translateX(-50%);bottom:14px;
  display:flex;gap:8px;flex-wrap:wrap;justify-content:center
}
#btns button{
  border:0;border-radius:999px;padding:10px 12px;background:rgba(0,0,0,.72);
  color:#fff;font:13px system-ui;border:1px solid rgba(255,255,255,.16)
}
#btns button:active{transform:scale(.97)}
</style>
</head>

<body>
<div id="version-badge">v8</div>

<div id="hud">
  <div><b>Status</b> v8 (failsafe: never blank + teleport worlds)</div>
  <div class="row">
    <button id="teleNext">Teleport Next</button>
    <button id="teleOrigin">Teleport Origin</button>
    <button id="toggleFollow">Follow: AUTO</button>
    <button id="reset">Reset</button>
  </div>
  <div class="small" id="msg">Booting…</div>
</div>

<div id="mobile" style="display:none">
  <div id="leftPad" class="pad"><div id="leftStick" class="stick"></div></div>
  <div id="rightPad" class="pad"><div id="rightStick" class="stick"></div></div>
  <div id="btns">
    <button id="bUp">Up</button>
    <button id="bDown">Down</button>
    <button id="bTele">Teleport</button>
    <button id="bReset">Reset</button>
  </div>
</div>

<canvas id="c"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
const msgEl = document.getElementById("msg");
const say = (t)=>msgEl.textContent = t;

if(!BABYLON.Engine.isSupported()){
  say("❌ WebGL NOT supported/enabled.");
  throw new Error("WebGL not supported");
}

const canvas = document.getElementById("c");
const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.05,0.25,0.25,1);

new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene).intensity = 1.25;
const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.4,-1,-0.25), scene);
sun.position = new BABYLON.Vector3(100,200,100);
sun.intensity = 1.8;

// ALWAYS-visible grid + proof cube
const grid = BABYLON.MeshBuilder.CreateGround("GRID", {width:1200, height:1200}, scene);
const gridMat = new BABYLON.StandardMaterial("GRID_MAT", scene);
gridMat.wireframe = true;
gridMat.emissiveColor = new BABYLON.Color3(0.2,0.9,1.0);
gridMat.diffuseColor = new BABYLON.Color3(0,0,0);
grid.material = gridMat;

const proof = BABYLON.MeshBuilder.CreateBox("PROOF", {size:8}, scene);
proof.position = new BABYLON.Vector3(0,5,25);
const proofMat = new BABYLON.StandardMaterial("PM", scene);
proofMat.emissiveColor = new BABYLON.Color3(1,0.2,0.2);
proof.material = proofMat;

// Camera (third-person orbit-ish around target)
const cam = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0,10,-35), scene);
cam.attachControl(canvas, true);
cam.minZ = 0.05;
cam.maxZ = 200000;

let followMode = "AUTO"; // AUTO / AVATAR / NONE
document.getElementById("toggleFollow").onclick = ()=>{
  followMode = (followMode==="AUTO") ? "AVATAR" : (followMode==="AVATAR") ? "NONE" : "AUTO";
  document.getElementById("toggleFollow").textContent = `Follow: ${followMode}`;
};

// Touch device?
function isTouchDevice(){ return matchMedia("(pointer:coarse)").matches || "ontouchstart" in window; }
if(isTouchDevice()) document.getElementById("mobile").style.display = "block";

// Basic helpers
function getOwnerRepo(){
  const owner = location.hostname.split(".")[0];
  const parts = location.pathname.split("/").filter(Boolean);
  const repo = parts.length ? parts[0] : (owner + ".github.io");
  return { owner, repo };
}
async function listGlbs(owner, repo){
  const api = `https://api.github.com/repos/${owner}/${repo}/contents/glb`;
  const r = await fetch(api, { headers:{ "Accept":"application/vnd.github+json" }});
  if(!r.ok) throw new Error(`GitHub API failed (${r.status}). Ensure /glb exists.`);
  const items = await r.json();
  return items
    .filter(x=>x && x.type==="file" && /\.glb$/i.test(x.name))
    .map(x=>({ name:x.name, url:x.download_url }))
    .sort((a,b)=>a.name.localeCompare(b.name));
}
function computeBounds(meshes){
  let min = new BABYLON.Vector3(+Infinity,+Infinity,+Infinity);
  let max = new BABYLON.Vector3(-Infinity,-Infinity,-Infinity);
  let ok = false;
  for(const m of meshes){
    if(!m.getTotalVertices || m.getTotalVertices()<=0) continue;
    m.computeWorldMatrix(true);
    const bi = m.getBoundingInfo();
    if(!bi) continue;
    min = BABYLON.Vector3.Minimize(min, bi.boundingBox.minimumWorld);
    max = BABYLON.Vector3.Maximize(max, bi.boundingBox.maximumWorld);
    ok = true;
  }
  const center = ok ? min.add(max).scale(0.5) : BABYLON.Vector3.Zero();
  const diag = ok ? BABYLON.Vector3.Distance(min,max) : 0;
  const size = ok ? max.subtract(min) : BABYLON.Vector3.Zero();
  return {ok,min,max,center,diag,size};
}
function forceAvatarVisible(mesh){
  if(mesh.material){
    mesh.material.backFaceCulling = false;
    if(mesh.material.alpha !== undefined && mesh.material.alpha < 0.5) mesh.material.alpha = 1.0;
    // mild emissive ONLY for avatar so it never disappears
    try{
      mesh.material.emissiveColor = new BABYLON.Color3(0.35,0.6,0.8);
    }catch(_){}
  } else {
    const m = new BABYLON.StandardMaterial("AV_MAT_"+mesh.name, scene);
    m.emissiveColor = new BABYLON.Color3(0.35,0.6,0.8);
    m.backFaceCulling = false;
    mesh.material = m;
  }
}
function makeWorldSafer(mesh){
  if(mesh.material){
    mesh.material.backFaceCulling = false;
    if(mesh.material.alpha !== undefined && mesh.material.alpha < 0.15) mesh.material.alpha = 1.0;
  }
}

// Cluster worlds around origin
function clusterPos(i){
  const spacing = 220;
  const row = Math.floor(i/3);
  const col = i%3;
  return new BABYLON.Vector3((col-1)*spacing, 0, (row)*spacing);
}

let avatar = null; // {root, yaw}
let avatarLoaded = false;

const worlds = []; // {name, root, pos, center}
let worldIndex = 0;

function lockTarget(pos){
  cam.setTarget(pos);
  // keep camera a safe distance
  const back = cam.getDirection(BABYLON.Axis.Z).scale(-1);
  if(back.lengthSquared()<0.001){
    cam.position = pos.add(new BABYLON.Vector3(0,10,-35));
  }
}

function getFollowTarget(){
  if(followMode==="NONE") return null;
  if(followMode==="AVATAR"){
    return (avatarLoaded && avatar && avatar.root) ? avatar.root.position : proof.position;
  }
  // AUTO
  if(avatarLoaded && avatar && avatar.root) return avatar.root.position;
  return proof.position;
}

function teleportToWorld(i){
  if(!worlds.length) return;
  worldIndex = (i + worlds.length) % worlds.length;
  const w = worlds[worldIndex];
  const p = (w.center) ? w.center.clone() : w.pos.clone();
  p.y = Math.max(0, p.y);

  // move camera + target
  cam.position = p.add(new BABYLON.Vector3(0, 10, -35));
  cam.setTarget(p);

  // move avatar if present
  if(avatarLoaded && avatar && avatar.root){
    avatar.root.position = p.clone();
    avatar.root.position.y = 0;
  }

  say(`World: ${w.name} (${worldIndex+1}/${worlds.length})`);
}

document.getElementById("teleNext").onclick = ()=>teleportToWorld(worldIndex+1);
document.getElementById("teleOrigin").onclick = ()=>{
  cam.position.set(0,10,-35);
  cam.setTarget(new BABYLON.Vector3(0,5,25));
  if(avatarLoaded && avatar && avatar.root) avatar.root.position.set(0,0,0);
  say("Teleported: origin");
};
document.getElementById("reset").onclick = ()=>{
  if(avatarLoaded && avatar){ avatar.yaw = 0; avatar.root.rotationQuaternion = BABYLON.Quaternion.Identity(); avatar.root.position.set(0,0,0); }
  cam.position.set(0,10,-35);
  cam.setTarget(new BABYLON.Vector3(0,5,25));
  say("Reset");
};

document.getElementById("bTele").onclick = ()=>teleportToWorld(worldIndex+1);
document.getElementById("bReset").onclick = ()=>document.getElementById("reset").click();

// Mobile sticks
let moveStick = {x:0,y:0};
let lookStick = {x:0,y:0};
let upHeld=false, downHeld=false;

function setupPad(padId, stickId, onMove){
  const pad = document.getElementById(padId);
  const stick = document.getElementById(stickId);
  const max = 55;
  let active=false, pid=null;

  const setStick=(dx,dy)=>{
    stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  };
  const end=()=>{ active=false; pid=null; setStick(0,0); onMove(0,0); };

  pad.addEventListener("pointerdown",(e)=>{ active=true; pid=e.pointerId; pad.setPointerCapture(pid); });
  pad.addEventListener("pointermove",(e)=>{
    if(!active || e.pointerId!==pid) return;
    const b = pad.getBoundingClientRect();
    const cx = b.left + b.width/2, cy = b.top + b.height/2;
    let dx = e.clientX - cx, dy = e.clientY - cy;
    const len = Math.hypot(dx,dy);
    if(len>max){ dx=dx/len*max; dy=dy/len*max; }
    setStick(dx,dy);
    onMove(dx/max, dy/max);
  });
  pad.addEventListener("pointerup", end);
  pad.addEventListener("pointercancel", end);
}
setupPad("leftPad","leftStick",(nx,ny)=>{ moveStick.x=nx; moveStick.y=-ny; });
setupPad("rightPad","rightStick",(nx,ny)=>{ lookStick.x=nx; lookStick.y=ny; });

function hold(btnId, setter){
  const b=document.getElementById(btnId);
  const on=()=>setter(true), off=()=>setter(false);
  b.addEventListener("pointerdown", on);
  b.addEventListener("pointerup", off);
  b.addEventListener("pointercancel", off);
  b.addEventListener("pointerleave", off);
}
hold("bUp", v=>upHeld=v);
hold("bDown", v=>downHeld=v);

// Desktop keys
const keys = new Set();
window.addEventListener("keydown", e=>keys.add(e.code));
window.addEventListener("keyup", e=>keys.delete(e.code));

// Wheel zoom (moves camera along its forward direction)
canvas.addEventListener("wheel",(e)=>{
  const forward = cam.getDirection(BABYLON.Axis.Z);
  cam.position.addInPlace(forward.scale(e.deltaY * 0.02));
  e.preventDefault();
},{passive:false});

/* Load all GLBs */
async function loadAll(){
  const {owner, repo} = getOwnerRepo();
  say(`v8 running.\nRepo: ${owner}/${repo}\nListing /glb…`);

  const glbs = await listGlbs(owner, repo);
  if(!glbs.length){ say("No .glb files found in /glb."); return; }

  const avatarFile = glbs.find(g=>g.name.toLowerCase()==="avatar.glb");
  const worldFiles = glbs.filter(g=>g!==avatarFile);

  say(`Found ${glbs.length} GLBs\nWorlds=${worldFiles.length} Avatar=${avatarFile? "YES":"NO"}`);

  // Worlds
  for(let i=0;i<worldFiles.length;i++){
    const g = worldFiles[i];
    const pos = clusterPos(i);
    try{
      const root = new BABYLON.TransformNode("WORLD_"+g.name, scene);
      const res = await BABYLON.SceneLoader.ImportMeshAsync("", "", g.url, scene);
      res.meshes.forEach(m=>{
        m.parent = root;
        m.isPickable = true;
        makeWorldSafer(m);
      });
      root.position = pos.clone();
      const b = computeBounds(root.getChildMeshes(false));
      worlds.push({name:g.name, root, pos, center: b.ok ? b.center : pos});
      say(`Loaded: ${g.name}\nmeshes=${res.meshes.length} diag=${Math.round(b.diag)}`);
    }catch(e){
      worlds.push({name:g.name, root:null, pos, center: pos});
      say(`FAILED: ${g.name}\n${String(e && (e.message||e) || e)}`);
    }
  }

  // Avatar
  if(avatarFile){
    try{
      const root = new BABYLON.TransformNode("AVATAR_ROOT", scene);
      const res = await BABYLON.SceneLoader.ImportMeshAsync("", "", avatarFile.url, scene);
      res.meshes.forEach(m=>{
        m.parent = root;
        m.isPickable = true;
        forceAvatarVisible(m);
      });
      root.position.set(0,0,0);
      avatar = {root, yaw:0};
      avatarLoaded = true;
      say("Avatar loaded ✅ (forced visible)");
    }catch(e){
      avatarLoaded = false;
      say(`Avatar FAILED ❌\n${String(e && (e.message||e) || e)}`);
    }
  } else {
    say("No avatar.glb found. Add /glb/avatar.glb");
  }

  // Start at first world (if any)
  if(worlds.length) teleportToWorld(0);
  else say("No worlds loaded. Only grid + cube visible.");
}

scene.onBeforeRenderObservable.add(()=>{
  const dt = Math.min(0.05, engine.getDeltaTime()/1000);
  proof.rotation.y += 0.01;

  // Follow target (never blank)
  const t = getFollowTarget();
  if(t) cam.setTarget(t);

  // Movement drives avatar if available, otherwise drives camera
  const speed = 7.0;
  const upSpeed = 5.0;

  let f=0,s=0,u=0;
  // Desktop
  if(keys.has("KeyW")) f += 1;
  if(keys.has("KeyS")) f -= 1;
  if(keys.has("KeyD")) s += 1;
  if(keys.has("KeyA")) s -= 1;
  if(keys.has("KeyE")) u += 1;
  if(keys.has("KeyQ")) u -= 1;

  // Mobile
  f += moveStick.y;
  s += moveStick.x;
  if(upHeld) u += 1;
  if(downHeld) u -= 1;

  // Look (mobile right stick)
  if(isTouchDevice()){
    cam.rotation.y += lookStick.x * dt * 2.2;
    cam.rotation.x += lookStick.y * dt * 1.6;
    const limit = 1.45;
    cam.rotation.x = Math.max(-limit, Math.min(limit, cam.rotation.x));
  }

  const forward = cam.getDirection(BABYLON.Axis.Z);
  const right = cam.getDirection(BABYLON.Axis.X);

  let v = forward.scale(f).add(right.scale(s));
  if(v.lengthSquared()>1e-6) v = v.normalize();

  if(avatarLoaded && avatar && avatar.root){
    avatar.root.position.addInPlace(v.scale(speed*dt));
    avatar.root.position.y += u * upSpeed * dt;
  } else {
    cam.position.addInPlace(v.scale(speed*dt));
    cam.position.y += u * upSpeed * dt;
  }
});

engine.runRenderLoop(()=>scene.render());
setTimeout(()=>engine.resize(),100);
window.addEventListener("resize",()=>engine.resize());

loadAll().catch(e=>say(String(e && (e.message||e) || e)));
</script>
</body>
</html>
