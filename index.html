<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport"
      content="width=device-width,height=device-height,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover"/>
<title>GLB World v13</title>

<style>
html,body{
  margin:0;width:100%;height:100%;overflow:hidden;
  background:#000;touch-action:none;-webkit-text-size-adjust:100%;
}
#c{width:100vw;height:100vh;display:block;background:#111;touch-action:none}

#badge{
  position:fixed;top:10px;right:10px;z-index:9999;
  padding:6px 10px;font:12px system-ui;color:#fff;
  background:rgba(0,0,0,.85);
  border:1px solid rgba(255,255,255,.35);
  border-radius:999px;pointer-events:none
}

#hud{
  position:fixed;top:10px;left:10px;z-index:9998;
  font:13px system-ui;color:#fff;
  background:rgba(0,0,0,.7);
  border:1px solid rgba(255,255,255,.15);
  padding:10px;border-radius:12px;
  max-width:calc(100vw - 180px)
}
#hud .small{opacity:.9;font-size:12px;margin-top:6px;white-space:pre-wrap}

#mobile{position:fixed;left:0;right:0;bottom:0;pointer-events:none}
.pad{
  pointer-events:auto;position:absolute;bottom:14px;
  width:150px;height:150px;border-radius:999px;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.2)
}
#leftPad{left:14px}
#rightPad{right:14px;width:170px;height:170px}
.stick{
  position:absolute;left:50%;top:50%;
  transform:translate(-50%,-50%);
  width:64px;height:64px;border-radius:999px;
  background:rgba(255,255,255,.2)
}
#btns{
  pointer-events:auto;position:absolute;left:50%;
  transform:translateX(-50%);bottom:14px;
  display:flex;gap:8px
}
#btns button{
  padding:10px 12px;border-radius:999px;
  background:rgba(0,0,0,.75);
  color:#fff;border:1px solid rgba(255,255,255,.2)
}
</style>
</head>

<body>
<div id="badge">v13</div>

<div id="hud">
  <div><b>Status</b> v13 (scale + controls locked)</div>
  <div class="small" id="msg">booting…</div>
</div>

<div id="mobile">
  <div id="leftPad" class="pad"><div id="leftStick" class="stick"></div></div>
  <div id="rightPad" class="pad"><div id="rightStick" class="stick"></div></div>
  <div id="btns">
    <button id="up">Up</button>
    <button id="down">Down</button>
    <button id="sprint">Sprint</button>
  </div>
</div>

<canvas id="c"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
/* ===== build + cache bust ===== */
const BUILD_ID = Date.now();
document.getElementById("badge").textContent = "v13 • " + BUILD_ID;

/* ===== basics ===== */
const msg = t => document.getElementById("msg").textContent = t;
const canvas = document.getElementById("c");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.05,0.25,0.25,1);

new BABYLON.HemisphericLight("h",new BABYLON.Vector3(0,1,0),scene).intensity=1.3;

/* ===== camera model (LOCKED) ===== */
const cam = new BABYLON.FollowCamera("cam",
  new BABYLON.Vector3(0,2,-6),scene);
cam.radius = 6;
cam.heightOffset = 2.2;
cam.rotationOffset = 180;
cam.cameraAcceleration = 0.25;
cam.maxCameraSpeed = 50;
scene.activeCamera = cam;

/* ===== reference grid ===== */
const grid = BABYLON.MeshBuilder.CreateGround("g",{width:1200,height:1200},scene);
const gm = new BABYLON.StandardMaterial("gm",scene);
gm.wireframe=true; gm.emissiveColor=new BABYLON.Color3(0,1,1);
grid.material=gm;

/* ===== helpers ===== */
function bounds(meshes){
  let min=new BABYLON.Vector3(1e9,1e9,1e9),
      max=new BABYLON.Vector3(-1e9,-1e9,-1e9),
      ok=false;
  for(const m of meshes){
    if(!m.getTotalVertices||m.getTotalVertices()===0) continue;
    m.computeWorldMatrix(true);
    const b=m.getBoundingInfo().boundingBox;
    min=BABYLON.Vector3.Minimize(min,b.minimumWorld);
    max=BABYLON.Vector3.Maximize(max,b.maximumWorld);
    ok=true;
  }
  return {ok,min,max,size:ok?max.subtract(min):BABYLON.Vector3.Zero()};
}
function dz(v,d=0.12,e=1.6){
  const a=Math.abs(v);
  if(a<d) return 0;
  const t=(a-d)/(1-d);
  return Math.sign(v)*Math.pow(t,e);
}

/* ===== input ===== */
let mv={x:0,y:0}, lk={x:0,y:0};
let up=false,down=false,sprint=false;

function stick(pad,stick,cb){
  const P=document.getElementById(pad);
  const S=document.getElementById(stick);
  const M=60; let id=null;
  const end=()=>{id=null;S.style.transform="translate(-50%,-50%)";cb(0,0);}
  P.onpointerdown=e=>{id=e.pointerId;P.setPointerCapture(id)};
  P.onpointermove=e=>{
    if(e.pointerId!==id) return;
    const r=P.getBoundingClientRect();
    let dx=e.clientX-(r.left+r.width/2),
        dy=e.clientY-(r.top+r.height/2);
    const l=Math.hypot(dx,dy); if(l>M){dx*=M/l;dy*=M/l;}
    S.style.transform=`translate(calc(-50%+${dx}px),calc(-50%+${dy}px))`;
    cb(dx/M,dy/M);
  };
  P.onpointerup=end; P.onpointercancel=end;
}
stick("leftPad","leftStick",(x,y)=>{mv.x=x;mv.y=-y});
stick("rightPad","rightStick",(x,y)=>{lk.x=x;lk.y=y});

["up","down","sprint"].forEach(id=>{
  document.getElementById(id).onpointerdown=()=>window[id]=true;
  document.getElementById(id).onpointerup=()=>window[id]=false;
});

/* ===== avatar (WORLD SCALE SOURCE) ===== */
let avatar=null;
let yaw=0,yawVel=0;

async function loadAvatar(url){
  const root=new BABYLON.TransformNode("AV",scene);
  const res=await BABYLON.SceneLoader.ImportMeshAsync("","",url,scene);
  res.meshes.forEach(m=>{
    m.parent=root;
    if(!m.material){
      const mat=new BABYLON.StandardMaterial("a",scene);
      mat.emissiveColor=new BABYLON.Color3(0.2,0.6,1);
      m.material=mat;
    }
    m.material.backFaceCulling=false;
  });
  const b=bounds(root.getChildMeshes());
  const h=b.size.y||1;
  const s=1.75/h;
  root.scaling.scaleInPlace(s);
  const b2=bounds(root.getChildMeshes());
  root.position.y-=b2.min.y;
  cam.lockedTarget=root;
  avatar=root;
}

/* ===== worlds ===== */
const worlds=[];
async function loadWorld(url){
  const root=new BABYLON.TransformNode("W",scene);
  const res=await BABYLON.SceneLoader.ImportMeshAsync("","",url,scene);
  res.meshes.forEach(m=>{
    m.parent=root;
    m.material.backFaceCulling=false;
  });
  const b=bounds(root.getChildMeshes());
  worlds.push({root,size:b.size});
}

/* ===== layout (NO OVERLAP) ===== */
function layout(){
  let x=0;
  for(const w of worlds){
    const half=Math.max(10,Math.min(60,w.size.length()*0.5));
    x+=half+20;
    w.root.position.x=x;
    x+=half;
  }
}

/* ===== movement loop ===== */
let vel=new BABYLON.Vector3();
scene.onBeforeRenderObservable.add(()=>{
  const dt=Math.min(0.05,engine.getDeltaTime()/1000);

  yawVel += dz(lk.x,0.08,1.2)*6*dt;
  yawVel *= 0.85;
  yaw += yawVel*dt;
  if(avatar) avatar.rotationQuaternion=BABYLON.Quaternion.FromEulerAngles(0,yaw,0);

  const f=dz(mv.y), s=dz(mv.x);
  const dir=new BABYLON.Vector3(Math.sin(yaw),0,Math.cos(yaw)).scale(f)
    .add(new BABYLON.Vector3(Math.sin(yaw+Math.PI/2),0,Math.cos(yaw+Math.PI/2)).scale(s));
  if(dir.length()>0) dir.normalize();

  const sp=(sprint?3:1)*30;
  vel=vel.add(dir.scale(sp*dt)).scale(0.9);
  if(avatar) avatar.position.addInPlace(vel.scale(dt));
  if(avatar) avatar.position.y += (up-down)*12*dt;
});

/* ===== boot ===== */
(async()=>{
  const owner=location.hostname.split(".")[0];
  const repo=location.pathname.split("/")[1];
  const list=await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/glb`).then(r=>r.json());
  const avatarFile=list.find(f=>f.name.toLowerCase()==="avatar.glb");
  const worldsFiles=list.filter(f=>f!==avatarFile);

  await loadAvatar(avatarFile.download_url);
  for(const w of worldsFiles) await loadWorld(w.download_url);
  layout();
  msg("running");
})();

engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
