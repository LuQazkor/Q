<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<meta name="apple-mobile-web-app-capable" content="yes"/>
<title>GLB Grid v18</title>

<style>
html,body{
  margin:0; width:100%; height:100%;
  overflow:hidden; background:#062222;
  touch-action:none;
}
canvas{display:block}

#badge{
  position:fixed; top:10px; right:10px;
  padding:6px 10px; font:12px system-ui;
  color:#fff; background:rgba(0,0,0,.82);
  border-radius:999px; z-index:20;
}

#panel{
  position:fixed; top:10px; left:10px;
  background:rgba(0,0,0,.55);
  color:#fff; font:13px system-ui;
  padding:12px; border-radius:14px; z-index:20;
  max-width:74vw;
}
#panel .row{ margin-top:8px; display:flex; gap:6px; flex-wrap:wrap; }
#panel button{
  padding:8px 12px; border-radius:999px;
  border:1px solid rgba(255,255,255,.2);
  background:rgba(0,0,0,.7); color:#fff;
}
#panel .mono{ font:12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New"; opacity:.95; }
#panel .dim{ opacity:.85; }

#minimap{
  position:fixed; right:10px; top:54px;
  width:140px; height:90px;
  background:rgba(0,0,0,.55);
  border:1px solid rgba(255,255,255,.15);
  border-radius:12px;
  z-index:20;
  overflow:hidden;
}
#minimap canvas{ width:100%; height:100%; }

#sticks{
  position:fixed; left:0; right:0; bottom:0;
  height:44vh; max-height:360px;
  pointer-events:none;
  z-index:25;
}
.stick{
  position:absolute;
  width:44vw; max-width:260px;
  height:44vw; max-height:260px;
  border-radius:50%;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.10);
  pointer-events:auto;
}
#leftStick{ left:16px; bottom:18px; }
#rightStick{ right:16px; bottom:18px; }

.knob{
  position:absolute; left:50%; top:50%;
  width:34%; height:34%;
  transform:translate(-50%,-50%);
  border-radius:50%;
  background:rgba(255,255,255,.14);
  border:1px solid rgba(255,255,255,.18);
}

#btnRow{
  position:fixed; left:50%; transform:translateX(-50%);
  bottom:16px;
  display:flex; gap:10px; z-index:30;
}
#btnRow button{
  pointer-events:auto;
  padding:10px 14px; border-radius:999px;
  border:1px solid rgba(255,255,255,.18);
  background:rgba(0,0,0,.55);
  color:#fff; font:13px system-ui;
}

@media (pointer:fine){
  #sticks, #btnRow{ display:none; }
}
</style>
</head>

<body>
<canvas id="c"></canvas>

<div id="badge">v18</div>

<div id="panel">
  <div><b>Status v18</b> — overwatch grid + normalized + avatar flight + real sticks</div>
  <div id="info" class="dim">loading…</div>
  <div class="row">
    <button id="mode">Mode: OVERWATCH</button>
    <button id="prev">Prev</button>
    <button id="next">Next</button>
    <button id="focus">Focus</button>
    <button id="reset">Reset</button>
  </div>
  <div class="mono" id="stats"></div>
</div>

<div id="minimap"><canvas id="mm"></canvas></div>

<div id="sticks">
  <div class="stick" id="leftStick"><div class="knob" id="leftKnob"></div></div>
  <div class="stick" id="rightStick"><div class="knob" id="rightKnob"></div></div>
</div>

<div id="btnRow">
  <button id="upBtn">Up</button>
  <button id="downBtn">Down</button>
  <button id="sprintBtn">Sprint</button>
</div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/loaders/GLTFLoader.js';

/* ---------------- BASIC SETUP ---------------- */
const VERSION = 'v18';
document.getElementById('badge').textContent = VERSION;

const canvas = document.getElementById('c');
const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
renderer.setPixelRatio(Math.min(2, devicePixelRatio));
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x062222);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 8000);

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* iOS Safari: prevent page zoom/scroll */
addEventListener('gesturestart', e=>e.preventDefault(), {passive:false});
addEventListener('touchmove', e=>e.preventDefault(), {passive:false});

/* ---------------- LIGHT + GRID ---------------- */
scene.add(new THREE.AmbientLight(0xffffff, 1.1));
const dir = new THREE.DirectionalLight(0xffffff, 0.85);
dir.position.set(80,140,60);
scene.add(dir);

const grid = new THREE.GridHelper(800, 80, 0x33ffff, 0x116666);
scene.add(grid);

/* ---------------- GLB LIST ----------------
   Put your worlds in /glb and list them here. */
const GLBS = [
  './glb/ICU.glb',
  './glb/office.glb',
  './glb/city_pack_8.glb',
  './glb/1970_dodge_challenger_rt.glb',
  './glb/dumbledores_office_2.glb'
];

/* Avatar file (optional). Put this at: /glb/avatar.glb */
const AVATAR_URL = './glb/avatar.glb';

/* ---------------- LOAD + NORMALIZE ---------------- */
const loader = new GLTFLoader();

const items = []; // {obj, name, key, center, diag, row, col}
let current = 0;

function boxInfo(obj){
  const box = new THREE.Box3().setFromObject(obj);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const diag = size.length();
  return {box,size,center,diag};
}

function normalizeTo(obj, targetDiag=40){
  const {box,diag} = boxInfo(obj);
  if(!isFinite(diag) || diag<=0) return {diag:0};

  const s = targetDiag / diag;
  obj.scale.setScalar(s);

  // Recompute and ground to y=0, center to origin.
  const b2 = new THREE.Box3().setFromObject(obj);
  const c2 = b2.getCenter(new THREE.Vector3());
  obj.position.sub(c2);
  obj.position.y -= b2.min.y;

  const b3 = new THREE.Box3().setFromObject(obj);
  const size3 = b3.getSize(new THREE.Vector3());
  const diag3 = size3.length();
  const center3 = b3.getCenter(new THREE.Vector3());
  return {diag:diag3, center:center3};
}

function groupKey(name){
  const n = name.toLowerCase();
  if(n.includes('icu') || n.includes('hospital') || n.includes('bed')) return 'medical';
  if(n.includes('office') || n.includes('desk')) return 'office';
  if(n.includes('city') || n.includes('street') || n.includes('town')) return 'city';
  if(n.includes('car') || n.includes('dodge') || n.includes('peugeot') || n.includes('vehicle')) return 'vehicle';
  if(n.includes('room') || n.includes('home') || n.includes('house')) return 'room';
  return 'misc';
}

async function loadWorlds(){
  for(const url of GLBS){
    try{
      const gltf = await loader.loadAsync(url);
      const obj = gltf.scene;
      const name = decodeURIComponent(url.split('/').pop());
      const key = groupKey(name);

      const norm = normalizeTo(obj, 44); // HARD normalized
      items.push({obj,name,key,diag:norm.diag});

      scene.add(obj);
    }catch(e){
      // keep going
    }
  }
}

/* ---------------- GRID LAYOUT (cluster by key) ---------------- */
function layoutGrid(){
  // cluster groups in blocks, still grid-like
  const by = new Map();
  for(const it of items){
    if(!by.has(it.key)) by.set(it.key, []);
    by.get(it.key).push(it);
  }
  const order = ['medical','office','city','vehicle','room','misc'];
  const groups = [];
  for(const k of order){
    if(by.has(k)) groups.push({k, arr: by.get(k)});
  }
  // any leftover keys
  for(const [k,arr] of by.entries()){
    if(!order.includes(k)) groups.push({k,arr});
  }

  const gap = 120;     // consistent spacing now that worlds are normalized
  const cols = 4;

  let index = 0;
  for(const g of groups){
    for(const it of g.arr){
      const r = Math.floor(index/cols);
      const c = index % cols;
      it.obj.position.x = (c - (cols-1)/2) * gap;
      it.obj.position.z = r * gap;
      index++;
    }
    // spacer row between groups
    index += cols; // jump one full row
  }

  // grid helper large enough
  grid.scale.setScalar(1);
}

/* ---------------- CAMERA MODES ---------------- */
let MODE = 'OVERWATCH'; // OVERWATCH | FOLLOW
const infoEl = document.getElementById('info');
const statsEl = document.getElementById('stats');

function resetOverwatch(){
  MODE = 'OVERWATCH';
  document.getElementById('mode').textContent = 'Mode: OVERWATCH';
  // Aim at center of all worlds
  const center = new THREE.Vector3();
  if(items.length){
    const b = new THREE.Box3();
    items.forEach(it=>b.expandByObject(it.obj));
    b.getCenter(center);
  }
  camera.position.set(center.x + 300, 420, center.z + 300);
  camera.lookAt(center);
}

function focusWorld(i){
  if(!items.length) return;
  current = (i + items.length) % items.length;
  const p = items[current].obj.position.clone();
  // Overwatch focus: closer but still above
  camera.position.set(p.x + 120, 160, p.z + 120);
  camera.lookAt(p);
  uiUpdate();
}

function setFollowMode(){
  MODE = 'FOLLOW';
  document.getElementById('mode').textContent = 'Mode: FOLLOW';
  uiUpdate();
}

function uiUpdate(){
  if(!items.length){
    infoEl.textContent = 'No worlds loaded. Check GLB list + /glb paths.';
    statsEl.textContent = '';
    return;
  }
  infoEl.textContent = `World ${current+1}/${items.length}: ${items[current].name}  | group=${items[current].key}`;
  statsEl.textContent =
    `worldDiag=${Math.round(items[current].diag||0)}\n` +
    `avatar=${avatar ? 'YES' : 'NO'}  mode=${MODE}\n` +
    `tip: tap minimap dots to focus`;
}

/* ---------------- AVATAR ---------------- */
let avatar = null;
let avatarRoot = new THREE.Group();
scene.add(avatarRoot);

function makeFallbackAvatar(){
  const g = new THREE.CapsuleGeometry(6, 18, 6, 12);
  const m = new THREE.MeshStandardMaterial({color:0x99ddff});
  const mesh = new THREE.Mesh(g,m);
  mesh.position.y = 18;
  const group = new THREE.Group();
  group.add(mesh);
  return group;
}

async function loadAvatar(){
  try{
    const gltf = await loader.loadAsync(AVATAR_URL);
    avatar = gltf.scene;
  }catch(e){
    avatar = makeFallbackAvatar();
  }
  // normalize avatar to human-ish size
  normalizeTo(avatar, 30);
  avatarRoot.add(avatar);

  // start at current world
  if(items.length){
    const p = items[current].obj.position.clone();
    avatarRoot.position.set(p.x, 0, p.z);
  }
}

/* ---------------- FOLLOW CAMERA + MOVEMENT ---------------- */
const tmpV = new THREE.Vector3();
let yaw = 0, pitch = -0.25;

function clamp(v,min,max){ return Math.max(min, Math.min(max,v)); }

function updateFollowCamera(dt){
  if(!avatarRoot) return;

  // Desired camera behind avatar based on yaw/pitch
  const back = 90;
  const up = 55;

  const dir = new THREE.Vector3(
    Math.sin(yaw) * Math.cos(pitch),
    Math.sin(pitch),
    Math.cos(yaw) * Math.cos(pitch)
  ).normalize();

  const camPos = avatarRoot.position.clone()
    .add(new THREE.Vector3(0, up, 0))
    .add(dir.clone().multiplyScalar(-back));

  camera.position.lerp(camPos, 1 - Math.pow(0.0001, dt)); // stable smoothing
  camera.lookAt(avatarRoot.position.clone().add(new THREE.Vector3(0, 28, 0)));
}

let moveX = 0, moveZ = 0; // strafe, forward
let flyY = 0;            // up/down
let sprintHeld = false;

function updateMovement(dt){
  if(MODE !== 'FOLLOW') return;

  // YOU SAID: left stick sluggish -> increase 5x.
  // So baseline is already fast, sprint is fastest.
  const baseSpeed = 140;      // was "too slow" -> big bump
  const sprintMult = 2.2;     // sprint faster
  const speed = baseSpeed * (sprintHeld ? sprintMult : 1);

  // Movement relative to yaw
  const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw)).normalize();
  const right = new THREE.Vector3(forward.z, 0, -forward.x).normalize();

  const v = new THREE.Vector3()
    .addScaledVector(right, moveX)
    .addScaledVector(forward, moveZ);

  if(v.lengthSq() > 1e-6) v.normalize();

  avatarRoot.position.addScaledVector(v, speed * dt);
  avatarRoot.position.y += flyY * (speed * 0.7) * dt;

  // keep avatar above "floor"
  avatarRoot.position.y = Math.max(0, avatarRoot.position.y);

  // face travel direction
  if(v.lengthSq() > 1e-6){
    avatarRoot.rotation.y = yaw;
  }
}

/* ---------------- INPUT: DESKTOP ---------------- */
const keys = new Set();
addEventListener('keydown', (e)=>{ keys.add(e.code); });
addEventListener('keyup', (e)=>{ keys.delete(e.code); });

let pointerLocked = false;
canvas.addEventListener('click', ()=>{
  if(matchMedia('(pointer:fine)').matches){
    canvas.requestPointerLock?.();
  }
});
document.addEventListener('pointerlockchange', ()=>{
  pointerLocked = (document.pointerLockElement === canvas);
});

document.addEventListener('mousemove', (e)=>{
  if(!pointerLocked) return;
  const sens = 0.0022; // sane
  yaw -= e.movementX * sens;
  pitch -= e.movementY * sens;
  pitch = clamp(pitch, -1.2, 0.3);
});

function updateDesktopKeys(){
  // WASD in FOLLOW only
  if(MODE !== 'FOLLOW') return;

  const f = (keys.has('KeyW') ? 1 : 0) + (keys.has('KeyS') ? -1 : 0);
  const s = (keys.has('KeyD') ? 1 : 0) + (keys.has('KeyA') ? -1 : 0);
  moveZ = clamp(f, -1, 1);
  moveX = clamp(s, -1, 1);

  flyY = (keys.has('Space') ? 1 : 0) + (keys.has('ShiftLeft') || keys.has('ShiftRight') ? -1 : 0);
  sprintHeld = keys.has('ControlLeft') || keys.has('ControlRight');
}

/* ---------------- INPUT: MOBILE STICKS (RIGHT STICK LOOK ONLY) ---------------- */
function makeStick(elStick, elKnob, onMove){
  let activeId = null;
  let cx=0, cy=0;
  let maxR = 0;

  function setKnob(dx,dy){
    elKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  }
  function reset(){
    activeId = null;
    setKnob(0,0);
    onMove(0,0, false);
  }

  elStick.addEventListener('pointerdown', (e)=>{
    activeId = e.pointerId;
    elStick.setPointerCapture(activeId);
    const r = elStick.getBoundingClientRect();
    cx = r.left + r.width/2;
    cy = r.top + r.height/2;
    maxR = Math.min(r.width, r.height) * 0.35;
    e.preventDefault();
  }, {passive:false});

  elStick.addEventListener('pointermove', (e)=>{
    if(e.pointerId !== activeId) return;
    const dx = e.clientX - cx;
    const dy = e.clientY - cy;
    const len = Math.hypot(dx,dy);
    const k = len > maxR ? (maxR/len) : 1;
    const sx = dx * k;
    const sy = dy * k;
    setKnob(sx, sy);

    const nx = clamp(sx / maxR, -1, 1);
    const ny = clamp(sy / maxR, -1, 1);
    onMove(nx, ny, true);
    e.preventDefault();
  }, {passive:false});

  elStick.addEventListener('pointerup', (e)=>{
    if(e.pointerId !== activeId) return;
    reset();
    e.preventDefault();
  }, {passive:false});

  elStick.addEventListener('pointercancel', (e)=>{
    if(e.pointerId !== activeId) return;
    reset();
  });

  return {reset};
}

const leftStick = makeStick(
  document.getElementById('leftStick'),
  document.getElementById('leftKnob'),
  (x,y,active)=>{
    // Left stick = MOVE ONLY.
    // y is down positive -> invert for forward
    moveX = x;           // strafe
    moveZ = -y;          // forward
  }
);

const rightStick = makeStick(
  document.getElementById('rightStick'),
  document.getElementById('rightKnob'),
  (x,y,active)=>{
    // Right stick = LOOK ONLY. No one-finger drag duplication.
    const lookSens = 1.9;   // you said right was too reactive -> lower
    yaw -= x * lookSens * 0.035;
    pitch -= y * lookSens * 0.025;
    pitch = clamp(pitch, -1.2, 0.3);
  }
);

// Buttons: up/down/sprint
const upBtn = document.getElementById('upBtn');
const downBtn = document.getElementById('downBtn');
const sprintBtn = document.getElementById('sprintBtn');

function holdBtn(el, onDown, onUp){
  el.addEventListener('pointerdown', (e)=>{ onDown(); e.preventDefault(); }, {passive:false});
  el.addEventListener('pointerup', (e)=>{ onUp(); e.preventDefault(); }, {passive:false});
  el.addEventListener('pointercancel', ()=>onUp());
  el.addEventListener('pointerleave', ()=>onUp());
}

holdBtn(upBtn, ()=>{ flyY = 1; }, ()=>{ if(flyY===1) flyY=0; });
holdBtn(downBtn, ()=>{ flyY = -1; }, ()=>{ if(flyY===-1) flyY=0; });
holdBtn(sprintBtn, ()=>{ sprintHeld = true; }, ()=>{ sprintHeld = false; });

/* Disable one-finger drag look entirely on mobile */
addEventListener('pointermove', (e)=>{
  if(matchMedia('(pointer:fine)').matches) return;
  // do nothing; sticks control look
}, {passive:false});

/* ---------------- MINIMAP (tap dot to focus) ---------------- */
const mm = document.getElementById('mm');
const mmr = mm.getContext('2d');

function sizeMinimap(){
  const r = mm.getBoundingClientRect();
  mm.width = Math.max(1, Math.floor(r.width * devicePixelRatio));
  mm.height = Math.max(1, Math.floor(r.height * devicePixelRatio));
}
addEventListener('resize', sizeMinimap);
sizeMinimap();

function drawMinimap(){
  const w = mm.width, h = mm.height;
  mmr.clearRect(0,0,w,h);
  mmr.fillStyle = 'rgba(0,0,0,0)';
  mmr.fillRect(0,0,w,h);

  if(!items.length) return;

  // compute bounds of world positions
  let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
  for(const it of items){
    minX = Math.min(minX, it.obj.position.x);
    maxX = Math.max(maxX, it.obj.position.x);
    minZ = Math.min(minZ, it.obj.position.z);
    maxZ = Math.max(maxZ, it.obj.position.z);
  }
  // include avatar
  minX = Math.min(minX, avatarRoot.position.x);
  maxX = Math.max(maxX, avatarRoot.position.x);
  minZ = Math.min(minZ, avatarRoot.position.z);
  maxZ = Math.max(maxZ, avatarRoot.position.z);

  const pad = 40;
  minX -= pad; maxX += pad; minZ -= pad; maxZ += pad;

  const sx = (x)=> ( (x - minX) / (maxX-minX) ) * (w-18) + 9;
  const sz = (z)=> ( (z - minZ) / (maxZ-minZ) ) * (h-18) + 9;

  // worlds
  for(let i=0;i<items.length;i++){
    const it = items[i];
    const x = sx(it.obj.position.x);
    const y = sz(it.obj.position.z);

    mmr.beginPath();
    mmr.arc(x,y, 5*devicePixelRatio, 0, Math.PI*2);

    if(i===current) mmr.fillStyle = 'rgba(255,80,80,.95)';
    else mmr.fillStyle = 'rgba(255,255,255,.70)';
    mmr.fill();
  }

  // avatar
  mmr.beginPath();
  mmr.arc(sx(avatarRoot.position.x), sz(avatarRoot.position.z), 4*devicePixelRatio, 0, Math.PI*2);
  mmr.fillStyle = 'rgba(70,220,255,.95)';
  mmr.fill();
}

mm.addEventListener('pointerdown', (e)=>{
  const r = mm.getBoundingClientRect();
  const x = (e.clientX - r.left) * devicePixelRatio;
  const y = (e.clientY - r.top) * devicePixelRatio;

  // brute: find nearest dot in current minimap draw space
  if(!items.length) return;

  // recompute bounds matching drawMinimap()
  let minX=Infinity, maxX=-Infinity, minZ=Infinity, maxZ=-Infinity;
  for(const it of items){
    minX = Math.min(minX, it.obj.position.x);
    maxX = Math.max(maxX, it.obj.position.x);
    minZ = Math.min(minZ, it.obj.position.z);
    maxZ = Math.max(maxZ, it.obj.position.z);
  }
  minX = Math.min(minX, avatarRoot.position.x);
  maxX = Math.max(maxX, avatarRoot.position.x);
  minZ = Math.min(minZ, avatarRoot.position.z);
  maxZ = Math.max(maxZ, avatarRoot.position.z);

  const pad = 40;
  minX -= pad; maxX += pad; minZ -= pad; maxZ += pad;

  const sx = (xx)=> ( (xx - minX) / (maxX-minX) ) * (mm.width-18) + 9;
  const sz = (zz)=> ( (zz - minZ) / (maxZ-minZ) ) * (mm.height-18) + 9;

  let best = 0, bestD = Infinity;
  for(let i=0;i<items.length;i++){
    const it = items[i];
    const dx = x - sx(it.obj.position.x);
    const dy = y - sz(it.obj.position.z);
    const d = dx*dx + dy*dy;
    if(d < bestD){ bestD = d; best = i; }
  }

  // tap radius threshold
  if(bestD < (18*devicePixelRatio)*(18*devicePixelRatio)){
    current = best;
    // teleport avatar to that world and follow it
    const p = items[current].obj.position;
    avatarRoot.position.set(p.x, 0, p.z);
    setFollowMode();
    uiUpdate();
  }
}, {passive:false});

/* ---------------- UI BUTTONS ---------------- */
document.getElementById('prev').onclick = ()=>{
  current = (current - 1 + items.length) % items.length;
  focusWorld(current);
};
document.getElementById('next').onclick = ()=>{
  current = (current + 1) % items.length;
  focusWorld(current);
};
document.getElementById('focus').onclick = ()=>{
  if(!items.length) return;
  // Teleport avatar to current and enter follow
  const p = items[current].obj.position;
  avatarRoot.position.set(p.x, 0, p.z);
  setFollowMode();
};
document.getElementById('reset').onclick = ()=>{
  leftStick.reset(); rightStick.reset();
  moveX=moveZ=0; flyY=0; sprintHeld=false;
  resetOverwatch();
  uiUpdate();
};
document.getElementById('mode').onclick = ()=>{
  if(MODE === 'OVERWATCH') setFollowMode();
  else resetOverwatch();
  uiUpdate();
};

/* ---------------- BOOT ---------------- */
resetOverwatch();

await loadWorlds();
layoutGrid();
await loadAvatar();

resetOverwatch();
uiUpdate();

/* ---------------- LOOP ---------------- */
let last = performance.now();
function loop(t){
  const dt = Math.min(0.05, (t-last)/1000);
  last = t;

  updateDesktopKeys();
  updateMovement(dt);
  if(MODE === 'FOLLOW') updateFollowCamera(dt);

  drawMinimap();
  renderer.render(scene,camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
