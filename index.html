<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hybrid GLB World</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
html,body{margin:0;overflow:hidden;background:#000;font-family:sans-serif}
#ui{
  position:fixed;top:10px;left:10px;z-index:10;
  background:rgba(0,0,0,.6);padding:10px;border-radius:8px;color:#fff
}
button,input,select{width:100%;margin:4px 0}
.joystick{
  position:fixed;bottom:20px;width:120px;height:120px;
  border-radius:50%;background:rgba(255,255,255,.1)
}
#leftJoy{left:20px}
#rightJoy{right:20px}
.knob{
  position:absolute;left:40px;top:40px;width:40px;height:40px;
  border-radius:50%;background:rgba(255,255,255,.4)
}
</style>
</head>
<body>

<div id="ui">
  <input type="file" id="fileInput" multiple accept=".glb">
  <button onclick="saveWorld()">ðŸ’¾ Save World</button>
  <select id="worlds" onchange="loadWorld()"></select>
</div>

<div id="leftJoy" class="joystick"><div class="knob"></div></div>
<div id="rightJoy" class="joystick"><div class="knob"></div></div>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/loaders/GLTFLoader.js';
import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.160/examples/jsm/controls/OrbitControls.js';

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x202020);

const camera=new THREE.PerspectiveCamera(70,innerWidth/innerHeight,0.1,10000);
camera.position.set(0,2,6);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const controls=new OrbitControls(camera,renderer.domElement);
controls.enableZoom=false;
controls.enablePan=false;

scene.add(new THREE.HemisphereLight(0xffffff,0x444444,1.2));

const ground=new THREE.Mesh(
  new THREE.PlaneGeometry(500,500),
  new THREE.MeshStandardMaterial({color:0x333333})
);
ground.rotation.x=-Math.PI/2;
scene.add(ground);

const loader=new GLTFLoader();
const objects=[];
const fileMap=new Map();
let avatar=null;

/* ---------- NORMALIZE ---------- */
function normalize(m){
  const box=new THREE.Box3().setFromObject(m);
  const size=box.getSize(new THREE.Vector3()).length();
  m.scale.setScalar(2/size);
}

/* ---------- LOAD FROM SERVER /glb ---------- */
async function loadServerGLBs(){
  try{
    const res=await fetch('/glb/index.json');
    const list=await res.json();
    list.forEach((name,i)=>{
      loader.load('/glb/'+name,g=>{
        const m=g.scene;
        normalize(m);
        m.position.set(i*5,0,0);
        m.userData.file=name;
        scene.add(m);
        objects.push(m);
        if(!avatar) avatar=m;
      });
    });
  }catch(e){
    console.warn('No /glb/index.json found');
  }
}
loadServerGLBs();

/* ---------- BROWSER UPLOAD ---------- */
fileInput.onchange=e=>{
  [...e.target.files].forEach((f,i)=>{
    const url=URL.createObjectURL(f);
    fileMap.set(f.name,url);
    loader.load(url,g=>{
      const m=g.scene;
      normalize(m);
      m.position.set(objects.length*4,0,0);
      m.userData.file=f.name;
      scene.add(m);
      objects.push(m);
      if(!avatar) avatar=m;
    });
  });
};

/* ---------- SAVE / LOAD WORLD ---------- */
function saveWorld(){
  const name=prompt('World name');
  if(!name) return;
  localStorage.setItem(
    'world_'+name,
    JSON.stringify(objects.map(o=>({
      file:o.userData.file,
      pos:o.position.toArray(),
      rot:o.rotation.toArray(),
      scale:o.scale.toArray()
    })))
  );
  refreshWorlds();
}
window.saveWorld=saveWorld;

function loadWorld(){
  const key='world_'+worlds.value;
  if(!localStorage.getItem(key)) return;

  objects.forEach(o=>scene.remove(o));
  objects.length=0;
  avatar=null;

  JSON.parse(localStorage.getItem(key)).forEach(d=>{
    const src=fileMap.get(d.file) || '/glb/'+d.file;
    loader.load(src,g=>{
      const m=g.scene;
      m.position.fromArray(d.pos);
      m.rotation.fromArray(d.rot);
      m.scale.fromArray(d.scale);
      m.userData.file=d.file;
      scene.add(m);
      objects.push(m);
      if(!avatar) avatar=m;
    });
  });
}

function refreshWorlds(){
  worlds.innerHTML='<option>Load World</option>';
  Object.keys(localStorage)
    .filter(k=>k.startsWith('world_'))
    .forEach(k=>{
      const o=document.createElement('option');
      o.textContent=o.value=k.replace('world_','');
      worlds.appendChild(o);
    });
}
refreshWorlds();

/* ---------- JOYSTICKS ---------- */
function joystick(el,cb){
  let a=false,k=el.firstChild;
  el.onpointerdown=()=>a=true;
  onpointerup=()=>{a=false;k.style.transform='';cb(0,0);}
  onpointermove=e=>{
    if(!a) return;
    const r=60,x=Math.max(-r,Math.min(r,e.movementX)),
          y=Math.max(-r,Math.min(r,e.movementY));
    k.style.transform=`translate(${x}px,${y}px)`;
    cb(x/r,y/r);
  };
}

const move={x:0,y:0,z:0};
joystick(leftJoy,(x,y)=>{move.x=x;move.z=y});
joystick(rightJoy,(x,y)=>{move.y=-y;move.x+=x*0.5});

/* ---------- LOOP ---------- */
function animate(){
  requestAnimationFrame(animate);
  if(avatar){
    avatar.position.x+=move.x*0.1;
    avatar.position.z+=move.z*0.1;
    avatar.position.y+=move.y*0.1;
    camera.position.lerp(
      avatar.position.clone().add(new THREE.Vector3(0,2,6)),0.1
    );
    camera.lookAt(avatar.position);
  }
  renderer.render(scene,camera);
}
animate();

onresize=()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
};
</script>
</body>
</html>