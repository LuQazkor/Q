<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>GLB World v6</title>

<style>
html,body{
  margin:0;width:100%;height:100%;overflow:hidden;
  background:#000;touch-action:none;-webkit-text-size-adjust:100%;
}
#c{width:100vw;height:100vh;display:block;background:#111;touch-action:none}

/* Version badge */
#version-badge{
  position:fixed;top:10px;right:10px;z-index:10000;
  padding:6px 10px;font:12px system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  color:#fff;background:rgba(0,0,0,.85);
  border:1px solid rgba(255,255,255,.30);
  border-radius:999px;pointer-events:none
}

/* HUD */
#hud{
  position:fixed;top:10px;left:10px;z-index:9999;
  max-width:calc(100vw - 20px);
  font:13px system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  color:#fff;background:rgba(0,0,0,.72);
  border:1px solid rgba(255,255,255,.14);
  padding:10px;border-radius:12px
}
#hud .small{opacity:.92;font-size:12px;margin-top:6px;white-space:pre-wrap}
#hud .row{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
#hud button{
  border:0;border-radius:999px;padding:8px 10px;
  background:rgba(255,255,255,.12);color:#fff;font:13px system-ui;
  border:1px solid rgba(255,255,255,.18)
}
#hud button:active{transform:scale(.97)}

/* Mobile controls */
#mobile{
  position:fixed;left:0;right:0;bottom:0;z-index:9998;pointer-events:none
}
.pad{
  pointer-events:auto;position:absolute;bottom:14px;
  width:150px;height:150px;border-radius:999px;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.18);
  backdrop-filter: blur(6px)
}
#leftPad{left:14px}
#rightPad{right:14px;width:170px;height:170px}
.stick{
  position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
  width:64px;height:64px;border-radius:999px;
  background:rgba(255,255,255,.18);
  border:1px solid rgba(255,255,255,.22)
}
#btns{
  pointer-events:auto;position:absolute;left:50%;transform:translateX(-50%);
  bottom:14px;display:flex;gap:8px;flex-wrap:wrap;justify-content:center
}
#btns button{
  border:0;border-radius:999px;padding:10px 12px;
  background:rgba(0,0,0,.72);color:#fff;font:13px system-ui;
  border:1px solid rgba(255,255,255,.16)
}
#btns button:active{transform:scale(.97)}
</style>
</head>

<body>
<div id="version-badge">v6</div>

<div id="hud">
  <div><b>Status</b> v6 (world lanes + avatar autoscale + touch pan/zoom)</div>
  <div class="row">
    <button id="prevWorld">Prev World</button>
    <button id="nextWorld">Next World</button>
    <button id="focus">Focus World</button>
    <button id="resetCam">Reset Cam</button>
  </div>
  <div class="small" id="msg">Booting…</div>
</div>

<div id="mobile" style="display:none">
  <div id="leftPad" class="pad"><div id="leftStick" class="stick"></div></div>
  <div id="rightPad" class="pad"><div id="rightStick" class="stick"></div></div>
  <div id="btns">
    <button id="bUp">Up</button>
    <button id="bDown">Down</button>
    <button id="bFocus">Focus</button>
    <button id="bReset">Reset</button>
  </div>
</div>

<canvas id="c"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
const msgEl = document.getElementById("msg");
const say = (t)=>msgEl.textContent = t;

if(!BABYLON.Engine.isSupported()){
  say("❌ WebGL NOT supported/enabled.");
  throw new Error("WebGL not supported");
}

const canvas = document.getElementById("c");
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true });
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.05,0.25,0.25,1);
scene.collisionsEnabled = true;

new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene).intensity = 1.35;
const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.4,-1,-0.3), scene);
sun.position = new BABYLON.Vector3(100,200,100);
sun.intensity = 2.2;

/* Camera */
const cam = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0, 6, -20), scene);
cam.attachControl(canvas, true);
cam.angularSensibility = 3000;
cam.minZ = 0.05;
cam.maxZ = 200000;
cam.checkCollisions = false;

/* Reference grid + proof cube */
const grid = BABYLON.MeshBuilder.CreateGround("GRID", {width:4000, height:4000}, scene);
const gridMat = new BABYLON.StandardMaterial("GRID_MAT", scene);
gridMat.wireframe = true;
gridMat.emissiveColor = new BABYLON.Color3(0.2,0.9,1.0);
gridMat.diffuseColor = new BABYLON.Color3(0,0,0);
grid.material = gridMat;

const proof = BABYLON.MeshBuilder.CreateBox("PROOF", {size:10}, scene);
proof.position = new BABYLON.Vector3(0,6,30);
const proofMat = new BABYLON.StandardMaterial("PM", scene);
proofMat.emissiveColor = new BABYLON.Color3(1,0.2,0.2);
proof.material = proofMat;

/* Device detection */
function isTouchDevice(){ return matchMedia("(pointer:coarse)").matches || "ontouchstart" in window; }
if(isTouchDevice()) document.getElementById("mobile").style.display = "block";

/* ---------------------- Touch camera gestures ----------------------
   1 finger drag: look
   2 finger drag: pan
   pinch: zoom
------------------------------------------------------------------- */
let activeTouches = new Map();
let lastPinchDist = null;

function getTouchesArray(){
  return Array.from(activeTouches.values()).sort((a,b)=>a.id-b.id);
}
function dist(a,b){
  const dx=a.x-b.x, dy=a.y-b.y;
  return Math.hypot(dx,dy);
}
function avg(a,b){ return {x:(a.x+b.x)/2, y:(a.y+b.y)/2}; }

canvas.addEventListener("pointerdown", (e)=>{
  canvas.setPointerCapture(e.pointerId);
  activeTouches.set(e.pointerId, {id:e.pointerId, x:e.clientX, y:e.clientY, px:e.clientX, py:e.clientY});
}, {passive:false});

canvas.addEventListener("pointermove", (e)=>{
  const t = activeTouches.get(e.pointerId);
  if(!t) return;
  t.px = t.x; t.py = t.y;
  t.x = e.clientX; t.y = e.clientY;

  const touches = getTouchesArray();
  if(touches.length === 1){
    // look
    const dx = touches[0].x - touches[0].px;
    const dy = touches[0].y - touches[0].py;
    cam.rotation.y += dx * 0.0035;
    cam.rotation.x += dy * 0.0028;
    const limit = 1.45;
    cam.rotation.x = Math.max(-limit, Math.min(limit, cam.rotation.x));
  } else if(touches.length >= 2){
    // pan + pinch
    const a = touches[0], b = touches[1];
    const prevA = {x:a.px,y:a.py}, prevB = {x:b.px,y:b.py};
    const prevMid = avg(prevA, prevB);
    const mid = avg(a,b);

    const panDx = mid.x - prevMid.x;
    const panDy = mid.y - prevMid.y;

    // pan in camera plane
    const right = cam.getDirection(BABYLON.Axis.X);
    const up = cam.getDirection(BABYLON.Axis.Y);
    cam.position.addInPlace(right.scale(-panDx * 0.01));
    cam.position.addInPlace(up.scale(panDy * 0.01));

    const d = dist(a,b);
    const prevD = dist(prevA, prevB);
    const pinchDelta = d - prevD;

    // zoom along forward
    const forward = cam.getDirection(BABYLON.Axis.Z);
    cam.position.addInPlace(forward.scale(pinchDelta * 0.05));
  }

  e.preventDefault();
}, {passive:false});

function endTouch(e){
  activeTouches.delete(e.pointerId);
  if(activeTouches.size < 2) lastPinchDist = null;
}
canvas.addEventListener("pointerup", endTouch, {passive:false});
canvas.addEventListener("pointercancel", endTouch, {passive:false});

/* Mouse wheel zoom */
canvas.addEventListener("wheel", (e)=>{
  const forward = cam.getDirection(BABYLON.Axis.Z);
  cam.position.addInPlace(forward.scale(e.deltaY * 0.01));
  e.preventDefault();
}, {passive:false});

/* ---------------------- Movement (desktop + mobile sticks) ---------------------- */
const keys = new Set();
window.addEventListener("keydown", e=>keys.add(e.code));
window.addEventListener("keyup", e=>keys.delete(e.code));

let moveStick = {x:0,y:0};
let lookStick = {x:0,y:0};
let upHeld=false, downHeld=false;

function setupPad(padId, stickId, onMove){
  const pad = document.getElementById(padId);
  const stick = document.getElementById(stickId);
  const max = 55;
  let active=false, pid=null;

  const setStick=(dx,dy)=>{
    stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  };
  const end=()=>{ active=false; pid=null; setStick(0,0); onMove(0,0); };

  pad.addEventListener("pointerdown",(e)=>{ active=true; pid=e.pointerId; pad.setPointerCapture(pid); });
  pad.addEventListener("pointermove",(e)=>{
    if(!active || e.pointerId!==pid) return;
    const b = pad.getBoundingClientRect();
    const cx = b.left + b.width/2, cy = b.top + b.height/2;
    let dx = e.clientX - cx, dy = e.clientY - cy;
    const len = Math.hypot(dx,dy);
    if(len>max){ dx=dx/len*max; dy=dy/len*max; }
    setStick(dx,dy);
    onMove(dx/max, dy/max);
  });
  pad.addEventListener("pointerup", end);
  pad.addEventListener("pointercancel", end);
}
setupPad("leftPad","leftStick",(nx,ny)=>{ moveStick.x=nx; moveStick.y=-ny; });
setupPad("rightPad","rightStick",(nx,ny)=>{ lookStick.x=nx; lookStick.y=ny; });

function hold(btnId, setter){
  const b=document.getElementById(btnId);
  const on=()=>setter(true), off=()=>setter(false);
  b.addEventListener("pointerdown", on);
  b.addEventListener("pointerup", off);
  b.addEventListener("pointercancel", off);
  b.addEventListener("pointerleave", off);
}
hold("bUp", v=>upHeld=v);
hold("bDown", v=>downHeld=v);

/* ---------------------- GLB loading ---------------------- */
function getOwnerRepo(){
  const owner = location.hostname.split(".")[0];
  const parts = location.pathname.split("/").filter(Boolean);
  const repo = parts.length ? parts[0] : (owner + ".github.io");
  return { owner, repo };
}

async function listGlbs(owner, repo){
  const api = `https://api.github.com/repos/${owner}/${repo}/contents/glb`;
  const r = await fetch(api, { headers:{ "Accept":"application/vnd.github+json" }});
  if(!r.ok) throw new Error(`GitHub API failed (${r.status}). Ensure /glb exists.`);
  const items = await r.json();
  return items
    .filter(x=>x && x.type==="file" && /\.glb$/i.test(x.name))
    .map(x=>({ name:x.name, url:x.download_url }))
    .sort((a,b)=>a.name.localeCompare(b.name));
}

/* Compute bounds (world) */
function computeBounds(meshes){
  let min = new BABYLON.Vector3(+Infinity,+Infinity,+Infinity);
  let max = new BABYLON.Vector3(-Infinity,-Infinity,-Infinity);
  let ok = false;
  for(const m of meshes){
    if(!m.getTotalVertices || m.getTotalVertices()<=0) continue;
    m.computeWorldMatrix(true);
    const bi = m.getBoundingInfo();
    if(!bi) continue;
    min = BABYLON.Vector3.Minimize(min, bi.boundingBox.minimumWorld);
    max = BABYLON.Vector3.Maximize(max, bi.boundingBox.maximumWorld);
    ok = true;
  }
  const center = ok ? min.add(max).scale(0.5) : BABYLON.Vector3.Zero();
  const diag = ok ? BABYLON.Vector3.Distance(min,max) : 0;
  const size = ok ? max.subtract(min) : BABYLON.Vector3.Zero();
  return {ok,min,max,center,diag,size};
}

function forceVisible(mesh){
  if(mesh.material){
    mesh.material.backFaceCulling = false;
    mesh.material.emissiveColor = new BABYLON.Color3(0.6,0.9,1.0);
  }
}

/* Avatar scaling to target height */
function scaleAvatarToHuman(avatarRoot){
  const meshes = avatarRoot.getChildMeshes(false);
  const b = computeBounds(meshes);
  if(!b.ok) return {height:0, scale:1};
  const height = Math.max(0.0001, b.size.y);
  const target = 1.75; // meters-ish
  let s = target / height;
  s = Math.max(0.001, Math.min(1000, s));
  avatarRoot.scaling = avatarRoot.scaling.scale(s);

  // Recenter to feet on y=0
  const b2 = computeBounds(meshes);
  if(b2.ok){
    const feetY = b2.min.y;
    avatarRoot.position.y -= feetY;
  }
  return {height, scale:s};
}

/* Worlds */
const LANE_SPACING = 700;
const worlds = []; // {name, root, pos, bounds}
let activeWorld = 0;

let avatar = null; // {root, meshes, info}

function focusWorld(i){
  if(i<0 || i>=worlds.length) return;
  activeWorld = i;
  const w = worlds[i];
  const b = w.bounds;
  if(b && b.ok){
    const d = Math.max(15, b.diag);
    cam.position = b.center.add(new BABYLON.Vector3(0, d*0.25 + 4, -d*1.1 - 8));
    cam.setTarget(b.center);
  }else{
    cam.position = w.pos.add(new BABYLON.Vector3(0,8,-25));
    cam.setTarget(w.pos.add(new BABYLON.Vector3(0,4,0)));
  }
  // Respawn avatar at this world
  if(avatar && avatar.root){
    avatar.root.position = w.pos.add(new BABYLON.Vector3(0,0,0));
  }
  say(`World: ${w.name} (${activeWorld+1}/${worlds.length})`);
}

document.getElementById("nextWorld").onclick = ()=>focusWorld((activeWorld+1)%worlds.length);
document.getElementById("prevWorld").onclick = ()=>focusWorld((activeWorld-1+worlds.length)%worlds.length);
document.getElementById("focus").onclick = ()=>focusWorld(activeWorld);
document.getElementById("resetCam").onclick = ()=>{ cam.position.set(0,6,-20); cam.setTarget(new BABYLON.Vector3(0,6,30)); };

document.getElementById("bFocus").onclick = ()=>focusWorld(activeWorld);
document.getElementById("bReset").onclick = ()=>{ cam.position.set(0,6,-20); cam.setTarget(new BABYLON.Vector3(0,6,30)); };

async function loadAll(){
  const {owner, repo} = getOwnerRepo();
  say(`v6 running.\nRepo: ${owner}/${repo}\nListing /glb…`);

  const glbs = await listGlbs(owner, repo);
  if(!glbs.length){
    say("No .glb files found in /glb.");
    return;
  }

  // Separate avatar.glb from worlds
  const avatarFile = glbs.find(g=>g.name.toLowerCase()==="avatar.glb");
  const worldFiles = glbs.filter(g=>g !== avatarFile);

  say(`Found ${glbs.length} GLBs.\nWorlds=${worldFiles.length}  Avatar=${avatarFile? "YES":"NO"}`);

  // Load worlds into lanes
  for(let i=0;i<worldFiles.length;i++){
    const g = worldFiles[i];
    const pos = new BABYLON.Vector3(i*LANE_SPACING, 0, 0);
    try{
      const root = new BABYLON.TransformNode("WORLD_"+g.name, scene);
      const res = await BABYLON.SceneLoader.ImportMeshAsync("", "", g.url, scene);
      res.meshes.forEach(m=>{
        m.parent = root;
        m.isPickable = true;
        forceVisible(m);
      });
      root.position = pos.clone();
      const b = computeBounds(root.getChildMeshes(false));
      worlds.push({name:g.name, root, pos, bounds:b});
      say(`Loaded world: ${g.name}\nmeshes=${res.meshes.length} diag=${Math.round(b.diag)}`);
    }catch(e){
      worlds.push({name:g.name, root:null, pos, bounds:{ok:false,diag:0,center:pos}});
      say(`FAILED world: ${g.name}\n${String(e && (e.message||e) || e)}`);
    }
  }

  // Load avatar (if present)
  if(avatarFile){
    try{
      const root = new BABYLON.TransformNode("AVATAR_ROOT", scene);
      const res = await BABYLON.SceneLoader.ImportMeshAsync("", "", avatarFile.url, scene);
      res.meshes.forEach(m=>{
        m.parent = root;
        m.isPickable = true;
        forceVisible(m);
      });
      const info = scaleAvatarToHuman(root);
      avatar = {root, meshes:res.meshes, info};
      say(`Loaded avatar: ${avatarFile.name}\nscaled x${info.scale.toFixed(3)}`);
    }catch(e){
      say(`FAILED avatar.glb\n${String(e && (e.message||e) || e)}`);
    }
  }

  if(!worlds.length){
    say("No worlds loaded (only avatar?)");
    return;
  }

  focusWorld(0);
}

/* Movement: camera moves (simple + reliable). Avatar follows camera x/z in current world. */
scene.onBeforeRenderObservable.add(()=>{
  const dt = engine.getDeltaTime()/1000;
  const spd = 7.5; // units/sec
  let f=0,s=0,u=0;

  // desktop
  if(keys.has("KeyW")) f += 1;
  if(keys.has("KeyS")) f -= 1;
  if(keys.has("KeyD")) s += 1;
  if(keys.has("KeyA")) s -= 1;
  if(keys.has("KeyE")) u += 1;
  if(keys.has("KeyQ")) u -= 1;

  // mobile sticks
  f += moveStick.y;
  s += moveStick.x;
  if(upHeld) u += 1;
  if(downHeld) u -= 1;

  // right stick look (mobile)
  if(isTouchDevice()){
    cam.rotation.y += lookStick.x * dt * 2.2;
    cam.rotation.x += lookStick.y * dt * 1.6;
    const limit = 1.45;
    cam.rotation.x = Math.max(-limit, Math.min(limit, cam.rotation.x));
  }

  const forward = cam.getDirection(BABYLON.Axis.Z);
  const right = cam.getDirection(BABYLON.Axis.X);

  let move = forward.scale(f).add(right.scale(s));
  if(move.lengthSquared() > 1e-6) move = move.normalize();

  cam.position.addInPlace(move.scale(spd * dt));
  cam.position.y += u * spd * 0.6 * dt;

  proof.rotation.y += 0.01;

  // Avatar follows camera x/z relative to active world (so it "travels")
  if(avatar && avatar.root && worlds[activeWorld]){
    const base = worlds[activeWorld].pos;
    avatar.root.position.x = cam.position.x; // match camera x in lane
    avatar.root.position.z = cam.position.z; // match camera z
    // Keep avatar near ground
    avatar.root.position.y = base.y;
  }
});

/* Boot */
engine.runRenderLoop(()=>scene.render());
setTimeout(()=>engine.resize(), 100);
window.addEventListener("resize", ()=>engine.resize());

loadAll().catch(e=>say(String(e && (e.message||e) || e)));
</script>
</body>
</html>
