<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>GLB World v5</title>

<style>
html,body{
  margin:0;width:100%;height:100%;overflow:hidden;
  background:#000;touch-action:none;-webkit-text-size-adjust:100%;
}
#c{width:100vw;height:100vh;display:block;background:#111}
#version-badge{
  position:fixed;top:10px;right:10px;z-index:10000;
  padding:6px 10px;font:12px system-ui;color:#fff;
  background:rgba(0,0,0,.85);border:1px solid rgba(255,255,255,.3);
  border-radius:999px;pointer-events:none
}
#hud{
  position:fixed;top:10px;left:10px;z-index:9999;
  max-width:calc(100vw - 20px);
  font:13px system-ui;color:#fff;
  background:rgba(0,0,0,.75);
  border:1px solid rgba(255,255,255,.15);
  padding:10px;border-radius:12px
}
#hud .small{font-size:12px;opacity:.9;white-space:pre-wrap;margin-top:6px}
#hud .row{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
#hud button{
  border:0;border-radius:999px;padding:8px 10px;
  background:rgba(255,255,255,.12);color:#fff;font:13px system-ui;
  border:1px solid rgba(255,255,255,.18)
}
#hud button:active{transform:scale(.97)}
</style>
</head>

<body>
<div id="version-badge">v5</div>

<div id="hud">
  <div><b>Status</b> v5 (truth mode)</div>
  <div class="row">
    <button id="focus">Focus Loaded</button>
    <button id="origin">Go Origin</button>
  </div>
  <div class="small" id="msg">Booting…</div>
</div>

<canvas id="c"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
const log = [];
const msgEl = document.getElementById("msg");
const say = (t)=>{ log.push(t); msgEl.textContent = log.slice(-12).join("\n"); };

if(!BABYLON.Engine.isSupported()){
  say("❌ WebGL NOT supported");
  throw new Error("WebGL not supported");
}

const canvas = document.getElementById("c");
const engine = new BABYLON.Engine(canvas,true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.05,0.25,0.25,1);

new BABYLON.HemisphericLight("h",new BABYLON.Vector3(0,1,0),scene).intensity=1.4;

const cam = new BABYLON.UniversalCamera("cam",new BABYLON.Vector3(0,6,-20),scene);
cam.attachControl(canvas,true);
cam.minZ=.05; cam.maxZ=100000;

const grid = BABYLON.MeshBuilder.CreateGround("grid",{width:3000,height:3000},scene);
const gm = new BABYLON.StandardMaterial("gm",scene);
gm.wireframe=true; gm.emissiveColor=new BABYLON.Color3(0,1,1); grid.material=gm;

const cube = BABYLON.MeshBuilder.CreateBox("cube",{size:10},scene);
cube.position.y=6;
const cm = new BABYLON.StandardMaterial("cm",scene);
cm.emissiveColor=new BABYLON.Color3(1,0,0); cube.material=cm;

function bounds(meshes){
  let min=new BABYLON.Vector3(1e9,1e9,1e9);
  let max=new BABYLON.Vector3(-1e9,-1e9,-1e9);
  let ok=false;
  for(const m of meshes){
    if(!m.getTotalVertices||m.getTotalVertices()===0) continue;
    m.computeWorldMatrix(true);
    const b=m.getBoundingInfo().boundingBox;
    min=BABYLON.Vector3.Minimize(min,b.minimumWorld);
    max=BABYLON.Vector3.Maximize(max,b.maximumWorld);
    ok=true;
  }
  return {ok,min,max,diag: ok?BABYLON.Vector3.Distance(min,max):0};
}

function focus(meshes){
  const b=bounds(meshes);
  if(!b.ok){ say("⚠️ No renderable geometry"); return; }
  const c=b.min.add(b.max).scale(.5);
  const d=Math.max(10,b.diag);
  cam.position=c.add(new BABYLON.Vector3(0,d*.3,-d*1.2));
  cam.setTarget(c);
}

document.getElementById("focus").onclick=()=>focus(scene.meshes);
document.getElementById("origin").onclick=()=>{
  cam.position.set(0,6,-20);
  cam.setTarget(new BABYLON.Vector3(0,6,0));
};

async function ownerRepo(){
  const owner=location.hostname.split(".")[0];
  const parts=location.pathname.split("/").filter(Boolean);
  return {owner,repo:parts[0]};
}

async function listGLBs(){
  const {owner,repo}=await ownerRepo();
  say(`Repo: ${owner}/${repo}`);
  const r=await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/glb`);
  if(!r.ok){ say("❌ /glb not found"); return []; }
  const j=await r.json();
  return j.filter(x=>x.type==="file"&&x.name.endsWith(".glb"));
}

async function loadAll(){
  const glbs=await listGLBs();
  if(!glbs.length){ say("⚠️ No GLBs in /glb"); return; }

  say(`Found ${glbs.length} GLBs`);

  let offset=0;
  for(const g of glbs){
    say(`→ ${g.name}: fetching`);
    try{
      const res=await BABYLON.SceneLoader.ImportMeshAsync("", "", g.download_url, scene);
      say(`✔ ${g.name}: loaded`);
      say(`  meshes=${res.meshes.length}`);
      let verts=0;
      res.meshes.forEach(m=>{
        m.position.x=offset;
        if(m.material){
          m.material.backFaceCulling=false;
          m.material.emissiveColor=new BABYLON.Color3(.6,.9,1);
        }
        if(m.getTotalVertices) verts+=m.getTotalVertices();
      });
      say(`  vertices=${verts}`);
      const b=bounds(res.meshes);
      say(`  diag=${Math.round(b.diag)}`);
      offset+=300;
      if(offset===300) focus(res.meshes);
    }catch(e){
      say(`❌ ${g.name} FAILED`);
    }
  }
}

engine.runRenderLoop(()=>scene.render());
setTimeout(()=>engine.resize(),100);
window.addEventListener("resize",()=>engine.resize());

say("Rendering OK");
loadAll();
</script>
</body>
</html>
