<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>GLB World v4</title>

<style>
html,body{
  margin:0;
  width:100%;
  height:100%;
  overflow:hidden;
  background:#000;
  touch-action:none;
  -webkit-text-size-adjust:100%;
}
#c{
  width:100vw;
  height:100vh;
  display:block;
  background:#111;
  touch-action:none;
}

/* Version badge (top-right) */
#version-badge{
  position:fixed;
  top:10px;
  right:10px;
  z-index:10000;
  padding:6px 10px;
  font:12px system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  color:#fff;
  background:rgba(0,0,0,.80);
  border:1px solid rgba(255,255,255,.30);
  border-radius:999px;
  pointer-events:none;
}

/* HUD */
#hud{
  position:fixed;
  top:10px;
  left:10px;
  z-index:9999;
  max-width:calc(100vw - 20px);
  font:13px system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  color:#fff;
  background:rgba(0,0,0,.70);
  border:1px solid rgba(255,255,255,.12);
  padding:10px;
  border-radius:12px;
}
#hud .small{
  opacity:.92;
  font-size:12px;
  margin-top:6px;
  white-space:pre-wrap;
}
#hud .row{
  margin-top:8px;
  display:flex;
  gap:8px;
  flex-wrap:wrap;
}
#hud button{
  border:0;
  border-radius:999px;
  padding:8px 10px;
  background:rgba(255,255,255,.12);
  color:#fff;
  font:13px system-ui;
  border:1px solid rgba(255,255,255,.14);
}
#hud button:active{transform:scale(.98)}

/* Mobile controls */
#mobile{
  position:fixed;
  left:0;
  right:0;
  bottom:0;
  z-index:9998;
  pointer-events:none;
}
.pad{
  pointer-events:auto;
  position:absolute;
  bottom:14px;
  width:150px;
  height:150px;
  border-radius:999px;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.18);
  backdrop-filter: blur(6px);
}
#leftPad{left:14px}
#rightPad{right:14px;width:170px;height:170px}
.stick{
  position:absolute;
  left:50%;
  top:50%;
  transform:translate(-50%,-50%);
  width:64px;
  height:64px;
  border-radius:999px;
  background:rgba(255,255,255,.18);
  border:1px solid rgba(255,255,255,.22);
}
#btns{
  pointer-events:auto;
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  bottom:14px;
  display:flex;
  gap:8px;
  flex-wrap:wrap;
  justify-content:center;
}
#btns button{
  border:0;
  border-radius:999px;
  padding:10px 12px;
  background:rgba(0,0,0,.70);
  color:#fff;
  font:13px system-ui;
  border:1px solid rgba(255,255,255,.14);
}
#btns button:active{transform:scale(.98)}
</style>
</head>

<body>
<div id="version-badge">v4</div>

<div id="hud">
  <div><b>Status</b> v4 (hard normalize + x-ray + safe camera)</div>
  <div class="row">
    <button id="teleNext">Teleport: Next GLB</button>
    <button id="teleOrigin">Teleport: Origin</button>
    <button id="toggleFly">Fly/Walk</button>
    <button id="toggleXray">X-Ray: ON</button>
    <button id="reset">Reset</button>
  </div>
  <div class="small" id="msg">Booting…</div>
</div>

<div id="mobile" style="display:none">
  <div id="leftPad" class="pad"><div id="leftStick" class="stick"></div></div>
  <div id="rightPad" class="pad"><div id="rightStick" class="stick"></div></div>
  <div id="btns">
    <button id="bFly">Fly/Walk</button>
    <button id="bUp">Up</button>
    <button id="bDown">Down</button>
    <button id="bUse">Interact</button>
    <button id="bReset">Reset</button>
  </div>
</div>

<canvas id="c"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
const msgEl = document.getElementById("msg");
const msg = (t)=>msgEl.textContent = t;

if(!BABYLON.Engine.isSupported()){
  msg("WEBGL NOT SUPPORTED/ENABLED on this browser.");
  throw new Error("WebGL not supported");
}

const canvas = document.getElementById("c");
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true });

engine.onContextLostObservable.add(()=>msg("WEBGL CONTEXT LOST (iOS memory/low power)."));
engine.onContextRestoredObservable.add(()=>msg("WEBGL CONTEXT RESTORED (reload page)."));

const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.05, 0.25, 0.25, 1);
scene.collisionsEnabled = true;

/* Lights (strong) */
new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene).intensity = 1.35;
const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.4,-1,-0.3), scene);
sun.position = new BABYLON.Vector3(100,200,100);
sun.intensity = 2.3;

/* Camera */
let flyMode = true;
const cam = new BABYLON.UniversalCamera("cam", new BABYLON.Vector3(0, 6, -20), scene);
cam.attachControl(canvas, true);
cam.angularSensibility = 3000;
cam.checkCollisions = true;
cam.ellipsoid = new BABYLON.Vector3(0.4,0.9,0.4);
cam.applyGravity = !flyMode;
cam.minZ = 0.05;
cam.maxZ = 100000;

const baseSpeed = 0.6;

/* Always-visible reference grid + rotating cube */
const grid = BABYLON.MeshBuilder.CreateGround("GRID", {width:3000, height:3000}, scene);
const gridMat = new BABYLON.StandardMaterial("GRID_MAT", scene);
gridMat.wireframe = true;
gridMat.emissiveColor = new BABYLON.Color3(0.2, 0.9, 1.0);
gridMat.diffuseColor = new BABYLON.Color3(0,0,0);
grid.material = gridMat;

const cube = BABYLON.MeshBuilder.CreateBox("PROOF_CUBE", {size:12}, scene);
cube.position = new BABYLON.Vector3(0, 8, 30);
const cubeMat = new BABYLON.StandardMaterial("CUBE_MAT", scene);
cubeMat.emissiveColor = new BABYLON.Color3(1.0, 0.2, 0.2);
cubeMat.diffuseColor = new BABYLON.Color3(0,0,0);
cubeMat.backFaceCulling = false;
cube.material = cubeMat;

/* Mobile detection */
function isTouchDevice(){
  return matchMedia("(pointer:coarse)").matches || "ontouchstart" in window;
}
if(isTouchDevice()){
  document.getElementById("mobile").style.display = "block";
}

/* Inputs */
const keys = new Set();
let moveVec = {x:0,y:0};
let lookVec = {x:0,y:0};
let upHeld=false, downHeld=false;

function toggleFlyWalk(){
  flyMode = !flyMode;
  cam.applyGravity = !flyMode;
  msg(flyMode ? "Mode: FLY" : "Mode: WALK");
}
function resetCam(){
  cam.position.set(0,6,-20);
  cam.rotation.set(0,0,0);
  cam.setTarget(new BABYLON.Vector3(0,6,30));
  msg("Reset");
}
function interact(){
  const p = scene.pick(engine.getRenderWidth()/2, engine.getRenderHeight()/2);
  if(p?.hit && p.pickedMesh){
    msg("INTERACT: " + p.pickedMesh.name);
  }else{
    msg("INTERACT: nothing");
  }
}

window.addEventListener("keydown", e=>{
  keys.add(e.code);
  if(e.code==="KeyF") toggleFlyWalk();
  if(e.code==="KeyR") resetCam();
  if(e.code==="KeyE") interact();
});
window.addEventListener("keyup", e=>keys.delete(e.code));

document.getElementById("toggleFly").onclick = toggleFlyWalk;
document.getElementById("reset").onclick = resetCam;

document.getElementById("bFly").onclick = toggleFlyWalk;
document.getElementById("bReset").onclick = resetCam;
document.getElementById("bUse").onclick = interact;

function hold(btnId, setter){
  const b=document.getElementById(btnId);
  const on=()=>setter(true), off=()=>setter(false);
  b.addEventListener("pointerdown", on);
  b.addEventListener("pointerup", off);
  b.addEventListener("pointercancel", off);
  b.addEventListener("pointerleave", off);
}
hold("bUp", v=>upHeld=v);
hold("bDown", v=>downHeld=v);

/* Joysticks */
function setupPad(padId, stickId, onMove){
  const pad = document.getElementById(padId);
  const stick = document.getElementById(stickId);
  const max = 55;
  let active=false, pid=null;

  const setStick=(dx,dy)=>{
    stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  };
  const end=()=>{ active=false; pid=null; setStick(0,0); onMove(0,0); };

  pad.addEventListener("pointerdown",(e)=>{ active=true; pid=e.pointerId; pad.setPointerCapture(pid); });
  pad.addEventListener("pointermove",(e)=>{
    if(!active || e.pointerId!==pid) return;
    const b = pad.getBoundingClientRect();
    const cx = b.left + b.width/2, cy = b.top + b.height/2;
    let dx = e.clientX - cx, dy = e.clientY - cy;
    const len = Math.hypot(dx,dy);
    if(len>max){ dx=dx/len*max; dy=dy/len*max; }
    setStick(dx,dy);
    onMove(dx/max, dy/max);
  });
  pad.addEventListener("pointerup", end);
  pad.addEventListener("pointercancel", end);
}
setupPad("leftPad","leftStick",(nx,ny)=>{ moveVec.x=nx; moveVec.y=-ny; });
setupPad("rightPad","rightStick",(nx,ny)=>{ lookVec.x=nx; lookVec.y=ny; });

/* Movement + look */
scene.onBeforeRenderObservable.add(()=>{
  const dt = engine.getDeltaTime()/1000;

  const sprint = keys.has("ControlLeft") || keys.has("ControlRight");
  const spd = (sprint ? baseSpeed*2.0 : baseSpeed);

  let f=0,s=0,u=0;

  if(keys.has("KeyW")) f += 1;
  if(keys.has("KeyS")) f -= 1;
  if(keys.has("KeyD")) s += 1;
  if(keys.has("KeyA")) s -= 1;

  f += moveVec.y;
  s += moveVec.x;

  if(flyMode){
    if(keys.has("Space")) u += 1;
    if(keys.has("ShiftLeft") || keys.has("ShiftRight")) u -= 1;
    if(upHeld) u += 1;
    if(downHeld) u -= 1;
  }

  const forward = cam.getDirection(BABYLON.Axis.Z);
  const right   = cam.getDirection(BABYLON.Axis.X);

  let move = forward.scale(f).add(right.scale(s));
  if(move.lengthSquared() > 1e-6) move = move.normalize().scale(spd);
  const vert = new BABYLON.Vector3(0, u*spd, 0);

  cam.moveWithCollisions(move.add(vert).scale(dt*60));

  if(isTouchDevice()){
    cam.rotation.y += lookVec.x * dt * 2.2;
    cam.rotation.x += lookVec.y * dt * 1.6;
    const limit = 1.45;
    cam.rotation.x = Math.max(-limit, Math.min(limit, cam.rotation.x));
  }

  cube.rotation.y += 0.01;
});

/* ---------- GLB LOADING + HARD NORMALIZE ---------- */
function getOwnerRepo(){
  const owner = location.hostname.split(".")[0];
  const parts = location.pathname.split("/").filter(Boolean);
  const repo = parts.length ? parts[0] : (owner + ".github.io");
  return { owner, repo };
}

async function listGlbs(owner, repo){
  const api = `https://api.github.com/repos/${owner}/${repo}/contents/glb`;
  const r = await fetch(api, { headers:{ "Accept":"application/vnd.github+json" }});
  if(!r.ok) throw new Error(`GitHub API failed (${r.status}). Ensure /glb exists in ${owner}/${repo}.`);
  const items = await r.json();
  return items
    .filter(x=>x && x.type==="file" && /\.glb$/i.test(x.name))
    .map(x=>({ name:x.name, url:x.download_url }))
    .sort((a,b)=>a.name.localeCompare(b.name));
}

/* X-RAY MODE (default ON) */
let xrayOn = true;
document.getElementById("toggleXray").onclick = ()=>{
  xrayOn = !xrayOn;
  document.getElementById("toggleXray").textContent = "X-Ray: " + (xrayOn ? "ON" : "OFF");
  applyXrayToAll();
};

function applyXray(mesh){
  if(!mesh || !mesh.material) return;
  mesh.material.backFaceCulling = false;
  mesh.material.disableLighting = false;

  if(xrayOn){
    // Strong emissive so it shows even if textures/materials are broken
    if(mesh.material.emissiveColor){
      mesh.material.emissiveColor = new BABYLON.Color3(0.6, 0.9, 1.0);
    }
    if(mesh.material.alpha !== undefined){
      mesh.material.alpha = 0.9;
    }
  }else{
    // Leave backFaceCulling off (safer), but remove emissive boost
    if(mesh.material.emissiveColor){
      mesh.material.emissiveColor = new BABYLON.Color3(0,0,0);
    }
    if(mesh.material.alpha !== undefined){
      mesh.material.alpha = 1.0;
    }
  }
}

function applyXrayToAll(){
  for(const m of scene.meshes){
    applyXray(m);
  }
}

/* Compute bounds in WORLD SPACE */
function computeWorldBounds(meshes){
  let min = new BABYLON.Vector3(+Infinity,+Infinity,+Infinity);
  let max = new BABYLON.Vector3(-Infinity,-Infinity,-Infinity);
  let found = false;

  for(const m of meshes){
    if(!m.getTotalVertices || m.getTotalVertices() <= 0) continue;
    m.computeWorldMatrix(true);
    const bi = m.getBoundingInfo();
    if(!bi) continue;
    min = BABYLON.Vector3.Minimize(min, bi.boundingBox.minimumWorld);
    max = BABYLON.Vector3.Maximize(max, bi.boundingBox.maximumWorld);
    found = true;
  }
  return { found, min, max };
}

/* Hard normalize:
   - center model at its spot
   - clamp scale so diagonal ~= targetDiag
*/
function hardNormalize(root, spotPos){
  const meshes = root.getChildMeshes(false);
  const b = computeWorldBounds(meshes);
  if(!b.found) return {center: spotPos.clone(), diag: 0};

  const center = b.min.add(b.max).scale(0.5);
  const diag = BABYLON.Vector3.Distance(b.min, b.max);

  // Move geometry center onto spot (preserve Y=0 baseline roughly)
  const delta = spotPos.subtract(center);
  root.position.addInPlace(delta);

  // Recompute bounds after translation
  const b2 = computeWorldBounds(meshes);
  if(!b2.found) return {center: spotPos.clone(), diag};

  const center2 = b2.min.add(b2.max).scale(0.5);
  const diag2 = BABYLON.Vector3.Distance(b2.min, b2.max);

  // Clamp scale
  const targetDiag = 140;   // desired approximate size per world
  const minDiag = 2;        // if tiny, don't explode scale
  const maxDiag = 50000;    // if huge, likely mm/cm
  let s = 1;

  if(diag2 > maxDiag){
    // super huge -> shrink hard
    s = targetDiag / diag2;
  }else if(diag2 > targetDiag*3){
    s = targetDiag / diag2;
  }else if(diag2 < minDiag){
    s = 1;
  }else if(diag2 < targetDiag*0.25){
    // a bit small -> modest scale up
    s = (targetDiag*0.7) / diag2;
  }

  s = Math.max(0.00001, Math.min(100, s));
  root.scaling = root.scaling.scale(s);

  // After scaling, recenter again (scaling moves bounds)
  const b3 = computeWorldBounds(meshes);
  if(b3.found){
    const center3 = b3.min.add(b3.max).scale(0.5);
    const delta2 = spotPos.subtract(center3);
    root.position.addInPlace(delta2);
  }

  return {center: spotPos.clone(), diag: diag2};
}

/* Safe camera: put camera OUTSIDE the bounding box */
function safeCameraTo(root, spotPos){
  const meshes = root.getChildMeshes(false);
  const b = computeWorldBounds(meshes);
  if(!b.found){
    teleportTo(spotPos);
    return;
  }

  const center = b.min.add(b.max).scale(0.5);
  const diag = BABYLON.Vector3.Distance(b.min, b.max);
  const radius = Math.max(10, diag * 0.65);

  // Approach from -Z with height
  cam.position = center.add(new BABYLON.Vector3(0, radius*0.25 + 10, -radius*1.25 - 20));
  cam.setTarget(center);
}

/* Beacons + teleport */
const spots = []; // {name,pos,root}
let spotIdx = 0;

function makeBeacon(label, pos){
  const s = BABYLON.MeshBuilder.CreateSphere("beacon_"+label, {diameter:10}, scene);
  s.position = pos.clone();
  const m = new BABYLON.StandardMaterial("bm_"+label, scene);
  m.emissiveColor = new BABYLON.Color3(0.2, 0.9, 1.0);
  m.diffuseColor = new BABYLON.Color3(0,0,0);
  m.backFaceCulling = false;
  s.material = m;
}

function teleportTo(pos){
  cam.position = pos.clone().add(new BABYLON.Vector3(0, 12, -30));
  cam.setTarget(pos.clone().add(new BABYLON.Vector3(0, 6, 0)));
}

document.getElementById("teleOrigin").onclick = ()=>teleportTo(new BABYLON.Vector3(0,0,0));
document.getElementById("teleNext").onclick = ()=>{
  if(!spots.length){ msg("No GLB spots loaded yet."); return; }
  const spot = spots[spotIdx % spots.length];
  spotIdx++;
  if(spot.root){
    safeCameraTo(spot.root, spot.pos);
  }else{
    teleportTo(spot.pos);
  }
  msg("Teleported: " + spot.name);
};

/* Load GLBs */
async function loadGlbs(){
  const {owner, repo} = getOwnerRepo();
  msg(`v4 running.\nRepo: ${owner}/${repo}\nListing /glb…`);

  const glbs = await listGlbs(owner, repo);
  if(!glbs.length){
    msg("No .glb files found in /glb.");
    return;
  }

  msg(`Found ${glbs.length} GLBs.\nLoading all with hard normalize…`);

  // Place worlds in a line, big spacing
  const spacing = 450;

  for(let i=0;i<glbs.length;i++){
    const g = glbs[i];
    const pos = new BABYLON.Vector3(i*spacing, 0, 0);

    makeBeacon(g.name, pos.add(new BABYLON.Vector3(0, 10, 0)));

    try{
      const root = new BABYLON.TransformNode("WORLD_"+g.name, scene);
      const res = await BABYLON.SceneLoader.ImportMeshAsync("", "", g.url, scene);

      res.meshes.forEach(m=>{
        m.parent = root;
        m.checkCollisions = true;
        m.isPickable = true;
        applyXray(m);
      });

      // Start near pos then hard normalize and safe camera for first world
      root.position = pos.clone();
      const info = hardNormalize(root, pos);

      spots.push({name:g.name, pos, root});

      if(i===0){
        safeCameraTo(root, pos);
      }

      msg(`Loaded: ${g.name}\nDiag(before clamp): ${Math.round(info.diag)}\nX-Ray: ${xrayOn ? "ON" : "OFF"}`);
    }catch(e){
      console.error("GLB failed:", g.name, e);
      spots.push({name:g.name, pos, root:null});
      msg(`FAILED: ${g.name}\n${String(e && (e.message||e) || e)}`);
    }
  }

  msg(`Loaded ${glbs.length}/${glbs.length}.\nTap Teleport: Next GLB.\nIf still black, X-Ray is ON (it should glow cyan).`);
}

/* Boot */
engine.runRenderLoop(()=>scene.render());
setTimeout(()=>engine.resize(), 100);
window.addEventListener("resize",()=>engine.resize());

document.getElementById("toggleXray").textContent = "X-Ray: ON";
document.getElementById("toggleFly").textContent = "Fly/Walk";

resetCam();
loadGlbs().catch(e=>msg(String(e && (e.message||e) || e)));
</script>
</body>
</html>
