<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>GLB Overwatch Viewer v21</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"/>

<style>
html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
  background: #0b3a3a;
  touch-action: none;
  font-family: system-ui, -apple-system, BlinkMacSystemFont;
}

#hud {
  position: absolute;
  top: 12px;
  left: 12px;
  right: 12px;
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 12px 14px;
  border-radius: 14px;
  font-size: 14px;
}

#version {
  position: absolute;
  top: 12px;
  right: 12px;
  background: #000;
  color: #6ff;
  padding: 6px 10px;
  border-radius: 999px;
  font-size: 12px;
}

#movePad {
  position: absolute;
  bottom: 24px;
  left: 50%;
  transform: translateX(-50%);
  width: 260px;
  height: 120px;
  border-radius: 60px;
  background: rgba(255,255,255,0.06);
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  grid-template-rows: 1fr 1fr;
  gap: 6px;
  padding: 10px;
}

.moveBtn {
  background: rgba(255,255,255,0.15);
  border-radius: 14px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  color: white;
  user-select: none;
}

.moveBtn:active {
  background: rgba(255,255,255,0.35);
}
</style>
</head>

<body>
<div id="hud">
  <b>FINAL HUMAN CONTROL MODEL (LOCKED)</b><br/>
  üëÅ Look: 1-finger drag anywhere<br/>
  üßç Move: arrows only (hold)<br/>
  ‚úã Tap: interact
</div>
<div id="version">v21</div>

<div id="movePad">
  <div class="moveBtn" data-dir="left">‚Üê</div>
  <div class="moveBtn" data-dir="forward">‚Üë</div>
  <div class="moveBtn" data-dir="right">‚Üí</div>
  <div class="moveBtn" data-dir="down">‚Üì</div>
  <div class="moveBtn" data-dir="up">‚Üë‚Üë</div>
  <div class="moveBtn" data-dir="downZ">‚Üì‚Üì</div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTFFileLoader.js"></script>

<script>
const canvas = document.createElement("canvas");
canvas.style.width = "100%";
canvas.style.height = "100%";
document.body.appendChild(canvas);

const engine = new BABYLON.Engine(canvas, true);
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.05,0.2,0.2,1);

const camera = new BABYLON.UniversalCamera("cam",
  new BABYLON.Vector3(0, 40, -60), scene);
camera.setTarget(BABYLON.Vector3.Zero());
camera.attachControl(canvas, false);

camera.speed = 0;
camera.angularSensibility = 800;

const light = new BABYLON.HemisphericLight("h",
  new BABYLON.Vector3(0,1,0), scene);

const grid = BABYLON.MeshBuilder.CreateGround("grid",
  {width:400, height:400}, scene);
const gridMat = new BABYLON.StandardMaterial("gm", scene);
gridMat.wireframe = true;
gridMat.emissiveColor = new BABYLON.Color3(0,1,1);
grid.material = gridMat;

let avatar;
BABYLON.SceneLoader.ImportMeshAsync(
  null, "/glb/", "avatar.glb", scene
).then(res=>{
  avatar = res.meshes[0];
  avatar.scaling.scaleInPlace(1);
  avatar.position = new BABYLON.Vector3(0,0,0);
});

const worlds = [];
const spacing = 40;
const files = [];

fetch("/glb/").catch(()=>{}); // keeps path alive

// MANUAL LIST ‚Äî SIMPLE & RELIABLE
const GLBS = [
  "ICU.glb",
  "office.glb",
  "city_pack_8.glb",
  "1970_dodge_challenger_rt.glb"
];

GLBS.forEach((name,i)=>{
  BABYLON.SceneLoader.ImportMeshAsync(
    null,"/glb/",name,scene
  ).then(res=>{
    const root = res.meshes[0];
    root.position = new BABYLON.Vector3(
      (i%4)*spacing - 60,
      0,
      Math.floor(i/4)*spacing
    );
    worlds.push(root);
  });
});

// LOOK = drag anywhere
let lastX,lastY;
canvas.addEventListener("pointerdown",e=>{
  lastX=e.clientX; lastY=e.clientY;
});
canvas.addEventListener("pointermove",e=>{
  if(e.buttons!==1) return;
  camera.rotation.y += (e.clientX-lastX)*0.002;
  camera.rotation.x += (e.clientY-lastY)*0.002;
  lastX=e.clientX; lastY=e.clientY;
});

// MOVE = arrows only
const moveState = {};
document.querySelectorAll(".moveBtn").forEach(b=>{
  const d=b.dataset.dir;
  b.addEventListener("pointerdown",()=>moveState[d]=true);
  b.addEventListener("pointerup",()=>moveState[d]=false);
  b.addEventListener("pointerleave",()=>moveState[d]=false);
});

scene.onBeforeRenderObservable.add(()=>{
  const speed = 0.6;
  if(moveState.forward) camera.position.z += speed;
  if(moveState.down) camera.position.z -= speed;
  if(moveState.left) camera.position.x -= speed;
  if(moveState.right) camera.position.x += speed;
  if(moveState.up) camera.position.y += speed;
  if(moveState.downZ) camera.position.y -= speed;
});

engine.runRenderLoop(()=>scene.render());
window.addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>
