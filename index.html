<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>GLB Overwatch Viewer v25</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no"/>

<style>
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
  background:#022a2a;
  touch-action:none;
  font-family:system-ui,-apple-system,BlinkMacSystemFont;
}

#hud{
  position:absolute;
  top:12px;
  left:12px;
  background:rgba(0,0,0,.7);
  color:#fff;
  padding:12px 14px;
  border-radius:14px;
  font-size:14px;
  z-index:10;
}

#version{
  position:absolute;
  top:12px;
  right:12px;
  background:#000;
  color:#6ff;
  padding:8px 12px;
  border-radius:999px;
  font-size:13px;
  font-weight:700;
  z-index:10;
}

#upload{
  position:absolute;
  top:90px;
  left:12px;
  background:#0ff;
  color:#000;
  padding:8px 12px;
  border-radius:10px;
  font-weight:600;
  cursor:pointer;
  z-index:10;
}

.joy{
  position:absolute;
  bottom:24px;
  width:140px;
  height:140px;
  border-radius:50%;
  background:rgba(255,255,255,.1);
  touch-action:none;
  z-index:10;
}

#joyL{ left:24px; }
#joyR{ right:24px; }

.knob{
  position:absolute;
  left:50%;
  top:50%;
  width:60px;
  height:60px;
  margin:-30px;
  border-radius:50%;
  background:rgba(255,255,255,.45);
}
</style>
</head>

<body>
<div id="hud">
<b>FINAL HUMAN CONTROL MODEL</b><br/>
üëÅ Look: 1-finger drag<br/>
üïπ Left: move | Right: lift + strafe<br/>
üì¶ Worlds: GitHub + Browser
</div>

<div id="version">v25</div>
<div id="upload">‚¨Ü Upload GLB</div>

<div id="joyL" class="joy"><div class="knob"></div></div>
<div id="joyR" class="joy"><div class="knob"></div></div>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylon.glTFFileLoader.js"></script>

<script>
console.log("GLB VIEWER v25");

/* -------------------- ENGINE -------------------- */
const canvas=document.createElement("canvas");
canvas.style.position="fixed";
canvas.style.top="0";
canvas.style.left="0";
canvas.style.width="100vw";
canvas.style.height="100vh";
document.body.appendChild(canvas);

const engine=new BABYLON.Engine(canvas,true);
const scene=new BABYLON.Scene(engine);
scene.clearColor=new BABYLON.Color4(0.02,0.25,0.25,1);

/* -------------------- CAMERA -------------------- */
const camera=new BABYLON.UniversalCamera(
  "cam",new BABYLON.Vector3(0,4,-12),scene
);
camera.attachControl(canvas,false);
scene.activeCamera=camera;

/* -------------------- LIGHT -------------------- */
new BABYLON.HemisphericLight("h",new BABYLON.Vector3(0,1,0),scene);

/* -------------------- GRID -------------------- */
const grid=BABYLON.MeshBuilder.CreateGround(
  "grid",{width:1000,height:1000},scene
);
const gm=new BABYLON.StandardMaterial("gm",scene);
gm.wireframe=true;
gm.emissiveColor=new BABYLON.Color3(0,1,1);
grid.material=gm;

/* -------------------- PLAYER -------------------- */
const player=new BABYLON.TransformNode("player",scene);

/* -------------------- JOYSTICKS -------------------- */
function makeJoy(el){
  const knob=el.querySelector(".knob");
  let dx=0,dy=0,active=false;

  el.addEventListener("pointerdown",e=>{
    active=true;
    el.setPointerCapture(e.pointerId);
  });

  el.addEventListener("pointermove",e=>{
    if(!active) return;
    const r=el.getBoundingClientRect();
    dx=(e.clientX-(r.left+r.width/2))/(r.width/2);
    dy=(e.clientY-(r.top+r.height/2))/(r.height/2);
    dx=Math.max(-1,Math.min(1,dx));
    dy=Math.max(-1,Math.min(1,dy));
    knob.style.transform=`translate(${dx*40}px,${dy*40}px)`;
  });

  el.addEventListener("pointerup",()=>{
    active=false; dx=dy=0;
    knob.style.transform="";
  });

  return ()=>({x:dx,y:dy});
}

const joyL=makeJoy(document.getElementById("joyL"));
const joyR=makeJoy(document.getElementById("joyR"));

/* -------------------- LOOK -------------------- */
let lx=0,ly=0,looking=false;
canvas.addEventListener("pointerdown",e=>{
  if(e.target.closest(".joy")) return;
  looking=true; lx=e.clientX; ly=e.clientY;
});
canvas.addEventListener("pointermove",e=>{
  if(!looking) return;
  camera.rotation.y+=(e.clientX-lx)*0.002;
  camera.rotation.x+=(e.clientY-ly)*0.002;
  camera.rotation.x=Math.max(-1.4,Math.min(1.4,camera.rotation.x));
  lx=e.clientX; ly=e.clientY;
});
canvas.addEventListener("pointerup",()=>looking=false);

/* -------------------- LOAD HELPERS -------------------- */
function normalizeAndPlace(root,i){
  const b=root.getHierarchyBoundingVectors();
  const size=b.max.subtract(b.min).length();
  root.scaling.scaleInPlace(10/size);
  root.position.set((i%5)*40-80,0,Math.floor(i/5)*40);
}

/* -------------------- LOAD GITHUB WORLDS -------------------- */
async function loadManifest(){
  try{
    const res=await fetch("/glb/index.json",{cache:"no-store"});
    const files=await res.json();
    let i=0;
    for(const f of files){
      const r=await BABYLON.SceneLoader.ImportMeshAsync(null,"/glb/",f,scene);
      if(f==="avatar.glb"){
        r.meshes[0].parent=player;
        camera.parent=player;
        camera.position.set(0,3,-8);
      }else{
        normalizeAndPlace(r.meshes[0],i++);
      }
    }
  }catch(e){
    console.warn("No manifest or blocked:",e);
  }
}

/* -------------------- LOAD BROWSER WORLDS -------------------- */
const saved=JSON.parse(localStorage.getItem("uploadedGLBs")||"[]");

async function loadUploaded(file,i){
  const url=URL.createObjectURL(file);
  const r=await BABYLON.SceneLoader.ImportMeshAsync(null,"",url,scene);
  normalizeAndPlace(r.meshes[0],i);
}

/* -------------------- UPLOAD -------------------- */
document.getElementById("upload").onclick=()=>{
  const input=document.createElement("input");
  input.type="file";
  input.accept=".glb";
  input.onchange=()=>{
    const file=input.files[0];
    saved.push(file);
    localStorage.setItem("uploadedGLBs",JSON.stringify(saved));
    loadUploaded(file,saved.length);
  };
  input.click();
};

/* -------------------- MOVEMENT -------------------- */
scene.onBeforeRenderObservable.add(()=>{
  const l=joyL(), r=joyR();
  const speed=0.6;

  const f=new BABYLON.Vector3(
    Math.sin(camera.rotation.y),0,
    Math.cos(camera.rotation.y)
  );
  const right=new BABYLON.Vector3(
    Math.sin(camera.rotation.y+Math.PI/2),0,
    Math.cos(camera.rotation.y+Math.PI/2)
  );

  player.position.addInPlace(f.scale(-l.y*speed));
  player.position.addInPlace(right.scale(l.x*speed));
  player.position.y+=r.y*speed;
  player.position.addInPlace(right.scale(r.x*speed));
});

/* -------------------- INIT -------------------- */
loadManifest();
saved.forEach(loadUploaded);

/* -------------------- LOOP -------------------- */
engine.runRenderLoop(()=>scene.render());
addEventListener("resize",()=>engine.resize());
</script>
</body>
</html>