<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>GLB World v7</title>

<style>
html,body{
  margin:0;width:100%;height:100%;overflow:hidden;
  background:#000;touch-action:none;-webkit-text-size-adjust:100%;
}
#c{width:100vw;height:100vh;display:block;background:#111;touch-action:none}

/* Version badge */
#version-badge{
  position:fixed;top:10px;right:10px;z-index:10000;
  padding:6px 10px;font:12px system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  color:#fff;background:rgba(0,0,0,.85);
  border:1px solid rgba(255,255,255,.30);
  border-radius:999px;pointer-events:none
}

/* HUD */
#hud{
  position:fixed;top:10px;left:10px;z-index:9999;
  max-width:calc(100vw - 20px);
  font:13px system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
  color:#fff;background:rgba(0,0,0,.72);
  border:1px solid rgba(255,255,255,.14);
  padding:10px;border-radius:12px
}
#hud .small{opacity:.92;font-size:12px;margin-top:6px;white-space:pre-wrap}
#hud .row{margin-top:8px;display:flex;gap:8px;flex-wrap:wrap}
#hud button{
  border:0;border-radius:999px;padding:8px 10px;
  background:rgba(255,255,255,.12);color:#fff;font:13px system-ui;
  border:1px solid rgba(255,255,255,.18)
}
#hud button:active{transform:scale(.97)}

/* Mobile controls */
#mobile{position:fixed;left:0;right:0;bottom:0;z-index:9998;pointer-events:none}
.pad{
  pointer-events:auto;position:absolute;bottom:14px;
  width:150px;height:150px;border-radius:999px;
  background:rgba(255,255,255,.08);
  border:1px solid rgba(255,255,255,.18);
  backdrop-filter: blur(6px)
}
#leftPad{left:14px}
#rightPad{right:14px;width:170px;height:170px}
.stick{
  position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);
  width:64px;height:64px;border-radius:999px;
  background:rgba(255,255,255,.18);
  border:1px solid rgba(255,255,255,.22)
}
#btns{
  pointer-events:auto;position:absolute;left:50%;transform:translateX(-50%);
  bottom:14px;display:flex;gap:8px;flex-wrap:wrap;justify-content:center
}
#btns button{
  border:0;border-radius:999px;padding:10px 12px;
  background:rgba(0,0,0,.72);color:#fff;font:13px system-ui;
  border:1px solid rgba(255,255,255,.16)
}
#btns button:active{transform:scale(.97)}
</style>
</head>

<body>
<div id="version-badge">v7</div>

<div id="hud">
  <div><b>Status</b> v7 (third-person follow + normalize + clustered)</div>
  <div class="row">
    <button id="prevWorld">Prev World</button>
    <button id="nextWorld">Next World</button>
    <button id="recenter">Recenter</button>
    <button id="toggleGrid">Grid</button>
    <button id="reset">Reset</button>
  </div>
  <div class="small" id="msg">Booting…</div>
</div>

<div id="mobile" style="display:none">
  <div id="leftPad" class="pad"><div id="leftStick" class="stick"></div></div>
  <div id="rightPad" class="pad"><div id="rightStick" class="stick"></div></div>
  <div id="btns">
    <button id="bUp">Up</button>
    <button id="bDown">Down</button>
    <button id="bRecenter">Recenter</button>
    <button id="bReset">Reset</button>
  </div>
</div>

<canvas id="c"></canvas>

<script src="https://cdn.babylonjs.com/babylon.js"></script>
<script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>

<script>
const msgEl = document.getElementById("msg");
const say = (t)=>msgEl.textContent = t;

if(!BABYLON.Engine.isSupported()){
  say("❌ WebGL NOT supported/enabled.");
  throw new Error("WebGL not supported");
}

const canvas = document.getElementById("c");
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer:true, stencil:true });
const scene = new BABYLON.Scene(engine);
scene.clearColor = new BABYLON.Color4(0.05,0.25,0.25,1);

// Better “real” rendering (no constant emissive blasting)
scene.imageProcessingConfiguration.exposure = 1.1;
scene.imageProcessingConfiguration.contrast = 1.05;

new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0,1,0), scene).intensity = 1.15;
const sun = new BABYLON.DirectionalLight("sun", new BABYLON.Vector3(-0.4,-1,-0.25), scene);
sun.position = new BABYLON.Vector3(100,200,100);
sun.intensity = 1.9;

// Grid (smaller so worlds don’t look tiny)
let gridOn = true;
const grid = BABYLON.MeshBuilder.CreateGround("GRID", {width:800, height:800}, scene);
const gridMat = new BABYLON.StandardMaterial("GRID_MAT", scene);
gridMat.wireframe = true;
gridMat.emissiveColor = new BABYLON.Color3(0.2,0.9,1.0);
gridMat.diffuseColor = new BABYLON.Color3(0,0,0);
grid.material = gridMat;

// Proof cube near origin
const proof = BABYLON.MeshBuilder.CreateBox("PROOF", {size:6}, scene);
proof.position = new BABYLON.Vector3(0,4,18);
const proofMat = new BABYLON.StandardMaterial("PM", scene);
proofMat.emissiveColor = new BABYLON.Color3(1,0.2,0.2);
proof.material = proofMat;

// Device detection
function isTouchDevice(){ return matchMedia("(pointer:coarse)").matches || "ontouchstart" in window; }
if(isTouchDevice()) document.getElementById("mobile").style.display = "block";

/* ---------------------- Helpers ---------------------- */
function getOwnerRepo(){
  const owner = location.hostname.split(".")[0];
  const parts = location.pathname.split("/").filter(Boolean);
  const repo = parts.length ? parts[0] : (owner + ".github.io");
  return { owner, repo };
}
async function listGlbs(owner, repo){
  const api = `https://api.github.com/repos/${owner}/${repo}/contents/glb`;
  const r = await fetch(api, { headers:{ "Accept":"application/vnd.github+json" }});
  if(!r.ok) throw new Error(`GitHub API failed (${r.status}). Ensure /glb exists.`);
  const items = await r.json();
  return items
    .filter(x=>x && x.type==="file" && /\.glb$/i.test(x.name))
    .map(x=>({ name:x.name, url:x.download_url }))
    .sort((a,b)=>a.name.localeCompare(b.name));
}
function computeBounds(meshes){
  let min = new BABYLON.Vector3(+Infinity,+Infinity,+Infinity);
  let max = new BABYLON.Vector3(-Infinity,-Infinity,-Infinity);
  let ok = false;
  for(const m of meshes){
    if(!m.getTotalVertices || m.getTotalVertices()<=0) continue;
    m.computeWorldMatrix(true);
    const bi = m.getBoundingInfo();
    if(!bi) continue;
    min = BABYLON.Vector3.Minimize(min, bi.boundingBox.minimumWorld);
    max = BABYLON.Vector3.Maximize(max, bi.boundingBox.maximumWorld);
    ok = true;
  }
  const center = ok ? min.add(max).scale(0.5) : BABYLON.Vector3.Zero();
  const diag = ok ? BABYLON.Vector3.Distance(min,max) : 0;
  const size = ok ? max.subtract(min) : BABYLON.Vector3.Zero();
  return {ok,min,max,center,diag,size};
}
function makeMaterialsSafer(mesh){
  if(!mesh.material) return;
  mesh.material.backFaceCulling = false;
  if(mesh.material.alpha !== undefined && mesh.material.alpha < 0.25) mesh.material.alpha = 1.0;
  // Do NOT force emissive on everything (that was washing you out)
}

/* Normalize a world root so its diagonal ~= TARGET_DIAG and its center sits at desiredPos */
function normalizeWorld(root, desiredPos){
  const meshes = root.getChildMeshes(false);
  let b = computeBounds(meshes);
  if(!b.ok) return {diag:0, scale:1};

  // Move center to desiredPos
  root.position.addInPlace(desiredPos.subtract(b.center));
  b = computeBounds(meshes);
  if(!b.ok) return {diag:0, scale:1};

  const TARGET_DIAG = 140; // makes ICU/office/city feel similar in size
  const diag = Math.max(0.0001, b.diag);
  let s = TARGET_DIAG / diag;

  // Clamp
  s = Math.max(0.0005, Math.min(50, s));
  root.scaling = root.scaling.scale(s);

  // Recenter after scaling
  b = computeBounds(meshes);
  if(b.ok){
    root.position.addInPlace(desiredPos.subtract(b.center));
    // Put “floor” near y=0 (optional, helps ICU not float)
    root.position.y -= b.min.y;
  }

  return {diag, scale:s};
}

/* Scale avatar to human height and put feet on y=0 */
function scaleAvatarToHuman(avatarRoot){
  const meshes = avatarRoot.getChildMeshes(false);
  let b = computeBounds(meshes);
  if(!b.ok) return {height:0, scale:1};
  const height = Math.max(0.0001, b.size.y);
  const TARGET_HEIGHT = 1.75;
  let s = TARGET_HEIGHT / height;
  s = Math.max(0.001, Math.min(200, s));
  avatarRoot.scaling = avatarRoot.scaling.scale(s);

  b = computeBounds(meshes);
  if(b.ok){
    avatarRoot.position.y -= b.min.y; // feet to y=0
  }
  return {height, scale:s};
}

/* ---------------------- Worlds + Avatar ---------------------- */
const worlds = []; // {name, root, pos, bounds}
let activeWorld = 0;

let avatar = null; // {root, yaw, v}
let followCam = null;

function clusterPos(i){
  // cluster worlds around origin (small spacing)
  const spacing = 220;
  return new BABYLON.Vector3(i*spacing, 0, 0);
}

function ensureFollowCamera(){
  if(followCam) return;
  followCam = new BABYLON.FollowCamera("follow", new BABYLON.Vector3(0, 2, -8), scene);
  followCam.radius = 7.5;            // zoom distance (pinch changes this)
  followCam.heightOffset = 2.1;      // above avatar
  followCam.rotationOffset = 180;    // behind avatar
  followCam.cameraAcceleration = 0.08;
  followCam.maxCameraSpeed = 8;
  followCam.attachControl(canvas, true);
  scene.activeCamera = followCam;
}

function respawnAtWorld(i){
  if(i<0 || i>=worlds.length) return;
  activeWorld = i;
  const w = worlds[i];
  if(avatar && avatar.root){
    avatar.root.position = w.pos.add(new BABYLON.Vector3(0,0,0));
    avatar.root.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, avatar.yaw, 0);
  }
  if(w.bounds && w.bounds.ok){
    say(`World: ${w.name} (${activeWorld+1}/${worlds.length})\nnormalized`);
  }else{
    say(`World: ${w.name} (${activeWorld+1}/${worlds.length})`);
  }
}

document.getElementById("nextWorld").onclick = ()=>respawnAtWorld((activeWorld+1)%worlds.length);
document.getElementById("prevWorld").onclick = ()=>respawnAtWorld((activeWorld-1+worlds.length)%worlds.length);
document.getElementById("recenter").onclick = ()=>respawnAtWorld(activeWorld);
document.getElementById("reset").onclick = ()=>{ if(avatar && avatar.root){ avatar.root.position.set(0,0,0); avatar.yaw=0; } respawnAtWorld(activeWorld); };
document.getElementById("toggleGrid").onclick = ()=>{
  gridOn = !gridOn;
  grid.setEnabled(gridOn);
  document.getElementById("toggleGrid").textContent = gridOn ? "Grid" : "Grid (off)";
};

document.getElementById("bRecenter").onclick = ()=>respawnAtWorld(activeWorld);
document.getElementById("bReset").onclick = ()=>{ if(avatar && avatar.root){ avatar.root.position.set(0,0,0); avatar.yaw=0; } respawnAtWorld(activeWorld); };

/* ---------------------- Controls (avatar-driven) ---------------------- */
const keys = new Set();
window.addEventListener("keydown", e=>keys.add(e.code));
window.addEventListener("keyup", e=>keys.delete(e.code));

let moveStick = {x:0,y:0};
let lookStick = {x:0,y:0};
let upHeld=false, downHeld=false;

function setupPad(padId, stickId, onMove){
  const pad = document.getElementById(padId);
  const stick = document.getElementById(stickId);
  const max = 55;
  let active=false, pid=null;

  const setStick=(dx,dy)=>{
    stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
  };
  const end=()=>{ active=false; pid=null; setStick(0,0); onMove(0,0); };

  pad.addEventListener("pointerdown",(e)=>{ active=true; pid=e.pointerId; pad.setPointerCapture(pid); });
  pad.addEventListener("pointermove",(e)=>{
    if(!active || e.pointerId!==pid) return;
    const b = pad.getBoundingClientRect();
    const cx = b.left + b.width/2, cy = b.top + b.height/2;
    let dx = e.clientX - cx, dy = e.clientY - cy;
    const len = Math.hypot(dx,dy);
    if(len>max){ dx=dx/len*max; dy=dy/len*max; }
    setStick(dx,dy);
    onMove(dx/max, dy/max);
  });
  pad.addEventListener("pointerup", end);
  pad.addEventListener("pointercancel", end);
}
setupPad("leftPad","leftStick",(nx,ny)=>{ moveStick.x=nx; moveStick.y=-ny; });
setupPad("rightPad","rightStick",(nx,ny)=>{ lookStick.x=nx; lookStick.y=ny; });

function hold(btnId, setter){
  const b=document.getElementById(btnId);
  const on=()=>setter(true), off=()=>setter(false);
  b.addEventListener("pointerdown", on);
  b.addEventListener("pointerup", off);
  b.addEventListener("pointercancel", off);
  b.addEventListener("pointerleave", off);
}
hold("bUp", v=>upHeld=v);
hold("bDown", v=>downHeld=v);

/* Pinch zoom -> changes follow camera radius only (less jank) */
let touchMap = new Map();
function dist(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy); }
canvas.addEventListener("pointerdown",(e)=>{
  canvas.setPointerCapture(e.pointerId);
  touchMap.set(e.pointerId,{id:e.pointerId,x:e.clientX,y:e.clientY,px:e.clientX,py:e.clientY});
},{passive:false});
canvas.addEventListener("pointermove",(e)=>{
  const t = touchMap.get(e.pointerId); if(!t) return;
  t.px=t.x; t.py=t.y; t.x=e.clientX; t.y=e.clientY;

  const arr = Array.from(touchMap.values());
  if(arr.length>=2 && followCam){
    const a=arr[0], b=arr[1];
    const prevD = dist({x:a.px,y:a.py},{x:b.px,y:b.py});
    const d = dist(a,b);
    const delta = d - prevD;
    followCam.radius = Math.max(2.2, Math.min(80, followCam.radius - delta*0.02));
    e.preventDefault();
  }
},{passive:false});
function endTouch(e){ touchMap.delete(e.pointerId); }
canvas.addEventListener("pointerup", endTouch, {passive:false});
canvas.addEventListener("pointercancel", endTouch, {passive:false});

/* Desktop wheel zoom */
canvas.addEventListener("wheel",(e)=>{
  if(followCam){
    followCam.radius = Math.max(2.2, Math.min(80, followCam.radius + e.deltaY*0.01));
  }
  e.preventDefault();
},{passive:false});

/* ---------------------- Load all GLBs ---------------------- */
async function loadAll(){
  const {owner, repo} = getOwnerRepo();
  say(`v7 running.\nRepo: ${owner}/${repo}\nListing /glb…`);

  const glbs = await listGlbs(owner, repo);
  if(!glbs.length){ say("No .glb files found in /glb."); return; }

  const avatarFile = glbs.find(g=>g.name.toLowerCase()==="avatar.glb");
  const worldFiles = glbs.filter(g=>g!==avatarFile);

  say(`Found ${glbs.length} GLBs\nWorlds=${worldFiles.length} Avatar=${avatarFile? "YES":"NO"}`);

  // Load worlds
  for(let i=0;i<worldFiles.length;i++){
    const g = worldFiles[i];
    const pos = clusterPos(i);
    try{
      const root = new BABYLON.TransformNode("WORLD_"+g.name, scene);
      const res = await BABYLON.SceneLoader.ImportMeshAsync("", "", g.url, scene);
      res.meshes.forEach(m=>{
        m.parent = root;
        m.isPickable = true;
        makeMaterialsSafer(m);
      });
      root.position = pos.clone();
      const info = normalizeWorld(root, pos.clone());
      const b = computeBounds(root.getChildMeshes(false));
      worlds.push({name:g.name, root, pos, bounds:b});
      say(`Loaded world: ${g.name}\nscale=${info.scale.toFixed(4)} diag=${Math.round(info.diag)}`);
    }catch(e){
      worlds.push({name:g.name, root:null, pos, bounds:{ok:false}});
      say(`FAILED world: ${g.name}\n${String(e && (e.message||e) || e)}`);
    }
  }

  // Load avatar
  if(avatarFile){
    try{
      const root = new BABYLON.TransformNode("AVATAR_ROOT", scene);
      const res = await BABYLON.SceneLoader.ImportMeshAsync("", "", avatarFile.url, scene);
      res.meshes.forEach(m=>{
        m.parent = root;
        m.isPickable = true;
        makeMaterialsSafer(m);
      });
      const info = scaleAvatarToHuman(root);
      avatar = {root, yaw:0, v:new BABYLON.Vector3(0,0,0)};
      ensureFollowCamera();
      followCam.lockedTarget = root;   // THIS is what makes you always see the avatar
      say(`Loaded avatar: avatar.glb\nscaled x${info.scale.toFixed(3)} (human height)`);
    }catch(e){
      say(`FAILED avatar.glb\n${String(e && (e.message||e) || e)}`);
    }
  } else {
    // Still create follow camera so you can navigate even without avatar
    ensureFollowCamera();
    followCam.lockedTarget = proof;
    say("No avatar.glb found. Add /glb/avatar.glb to see third-person avatar.");
  }

  if(!worlds.length){
    say("No worlds loaded (only avatar?)");
    return;
  }

  respawnAtWorld(0);
}

/* ---------------------- Update loop: avatar movement + camera follow ---------------------- */
scene.onBeforeRenderObservable.add(()=>{
  const dt = Math.min(0.05, engine.getDeltaTime()/1000);

  proof.rotation.y += 0.01;

  if(!avatar || !avatar.root) return;

  // Look = rotate avatar yaw (mobile right stick OR desktop drag is already on followCam, but we use stick too)
  const lookSpeed = 2.2;
  if(isTouchDevice()){
    avatar.yaw += lookStick.x * lookSpeed * dt;
  }

  // Desktop mouse drag: use pointer movement by reading camera alpha? FollowCamera doesn't expose alpha like ArcRotate.
  // We'll keep desktop look simple: hold left mouse and drag rotates followCam by attachControl; avatar moves relative to its yaw.

  avatar.root.rotationQuaternion = BABYLON.Quaternion.FromEulerAngles(0, avatar.yaw, 0);

  // Move input
  let f=0, s=0, u=0;

  // Desktop
  if(keys.has("KeyW")) f += 1;
  if(keys.has("KeyS")) f -= 1;
  if(keys.has("KeyD")) s += 1;
  if(keys.has("KeyA")) s -= 1;
  if(keys.has("KeyE")) u += 1;
  if(keys.has("KeyQ")) u -= 1;

  // Mobile
  f += moveStick.y;
  s += moveStick.x;
  if(upHeld) u += 1;
  if(downHeld) u -= 1;

  // Movement relative to avatar yaw
  const speed = 7.0;          // feel
  const upSpeed = 5.0;        // vertical feel
  const yaw = avatar.yaw;

  const forward = new BABYLON.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const right   = new BABYLON.Vector3(Math.sin(yaw + Math.PI/2), 0, Math.cos(yaw + Math.PI/2));

  let v = forward.scale(f).add(right.scale(s));
  if(v.lengthSquared() > 1e-6) v = v.normalize().scale(speed);

  // Apply
  avatar.root.position.addInPlace(v.scale(dt));
  avatar.root.position.y += u * upSpeed * dt;

  // Keep avatar near the active world baseline (so you don't drift to infinity)
  const w = worlds[activeWorld];
  if(w){
    // Soft pull toward the current world’s cluster x area
    const targetX = w.pos.x;
    avatar.root.position.x += (targetX - avatar.root.position.x) * 0.02;
  }
});

/* Boot */
engine.runRenderLoop(()=>scene.render());
setTimeout(()=>engine.resize(), 100);
window.addEventListener("resize", ()=>engine.resize());

loadAll().catch(e=>say(String(e && (e.message||e) || e)));
</script>
</body>
</html>
